"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/radar-sdk-js";
exports.ids = ["vendor-chunks/radar-sdk-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/radar-sdk-js/dist/radar.js":
/*!*************************************************!*\
  !*** ./node_modules/radar-sdk-js/dist/radar.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Radar)\n/* harmony export */ });\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maplibre-gl */ \"(ssr)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n\n\nclass Config {\n    static setup(options = {}) {\n        Config.options = options;\n    }\n    static get() {\n        return Config.options || {};\n    }\n    static clear() {\n        Config.options = {};\n    }\n}\nConfig.defaultOptions = {\n    live: false,\n    logLevel: 'error',\n    host: 'https://api.radar.io',\n    version: 'v1',\n    debug: false,\n};\n\nconst LOG_LEVELS = {\n    none: 0,\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4,\n};\n// get the numeric level for logLevel option\nconst getLevel = () => {\n    // disable logging in tests\n    if (window && window.RADAR_TEST_ENV) {\n        return LOG_LEVELS.none;\n    }\n    const { logLevel, debug } = Config.get();\n    if (debug) {\n        return LOG_LEVELS.debug;\n    }\n    if (logLevel) {\n        return LOG_LEVELS[logLevel];\n    }\n    return LOG_LEVELS.error; // default to error-level logging if not set\n};\nclass Logger {\n    static debug(message) {\n        if (getLevel() === LOG_LEVELS.debug) {\n            console.log(`Radar SDK (debug): ${message.trim()}`);\n        }\n    }\n    static info(message) {\n        if (getLevel() >= LOG_LEVELS.info) {\n            console.log(`Radar SDK: ${message.trim()}`);\n        }\n    }\n    static warn(message) {\n        if (getLevel() >= LOG_LEVELS.warn) {\n            console.warn(`Radar SDK: ${message.trim()}`);\n        }\n    }\n    static error(message) {\n        if (getLevel() >= LOG_LEVELS.error) {\n            console.error(`Radar SDK: ${message.trim()}`);\n        }\n    }\n}\n\nclass Storage {\n    // local storage key definitions for identifying track users\n    static get USER_ID() {\n        return 'radar-userId';\n    }\n    static get DEVICE_ID() {\n        return 'radar-deviceId';\n    }\n    static get INSTALL_ID() {\n        return 'radar-installId';\n    }\n    static get SESSION_ID() {\n        return 'radar-sessionId';\n    }\n    static get DESCRIPTION() {\n        return 'radar-description';\n    }\n    static get METADATA() {\n        return 'radar-metadata';\n    }\n    static get CACHED_LOCATION() {\n        return 'radar-cached-location';\n    }\n    static get TRIP_OPTIONS() {\n        return 'radar-trip-options';\n    }\n    static getStorage() {\n        const storage = window === null || window === void 0 ? void 0 : window.localStorage;\n        if (!storage) {\n            Logger.warn('localStorage not available.');\n        }\n        return storage;\n    }\n    static setItem(key, value) {\n        const storage = this.getStorage();\n        if (!storage) {\n            return;\n        }\n        if (value === undefined || value === null) {\n            return;\n        }\n        storage.setItem(key, value);\n    }\n    static getItem(key) {\n        const storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        const value = storage.getItem(key);\n        if (value !== undefined && value !== null) {\n            return value;\n        }\n        return null;\n    }\n    static getJSON(key) {\n        const item = this.getItem(key);\n        if (!item) {\n            return null;\n        }\n        try {\n            return JSON.parse(item);\n        }\n        catch (err) {\n            Logger.warn(`could not getJSON from storage for key: ${key}`);\n            return null;\n        }\n    }\n    static removeItem(key) {\n        const storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        storage.removeItem(key);\n    }\n    static clear() {\n        const storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        storage.clear();\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nclass RadarError extends Error {\n    constructor(message) {\n        super(message);\n        this.status = ''; // to be overridden (support for legacy status)\n    }\n}\nclass RadarPublishableKeyError extends RadarError {\n    constructor(message) {\n        super(message);\n        this.name = 'RadarPublishableKeyError';\n        this.status = 'ERROR_PUBLISHABLE_KEY';\n    }\n}\nclass RadarLocationError extends RadarError {\n    constructor(message) {\n        super(message);\n        this.name = 'RadarLocationError';\n        this.status = 'ERROR_LOCATION';\n    }\n}\nclass RadarPermissionsError extends RadarError {\n    constructor(message) {\n        super(message);\n        this.name = 'RadarPermissionsError';\n        this.status = 'ERROR_PERMISSIONS';\n    }\n}\nclass RadarVerifyAppError extends RadarError {\n    constructor() {\n        super('Radar Verify app not running.');\n        this.name = 'RadarVerifyAppError';\n        this.status = 'ERROR_VERIFY_APP';\n    }\n}\n// HTTP Errors\nclass RadarBadRequestError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Bad request.');\n        this.name = 'RadarBadRequestError';\n        this.code = 400;\n        this.response = response;\n        this.status = 'ERROR_BAD_REQUEST';\n    }\n}\nclass RadarUnauthorizedError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Unauthorized.');\n        this.name = 'RadarUnauthorizedError';\n        this.code = 401;\n        this.response = response;\n        this.status = 'ERROR_UNAUTHORIZED';\n    }\n}\nclass RadarPaymentRequiredError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Payment required.');\n        this.name = 'RadarPaymentRequiredError';\n        this.code = 402;\n        this.response = response;\n        this.status = 'ERROR_PAYMENT_REQUIRED';\n    }\n}\nclass RadarForbiddenError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Forbidden.');\n        this.name = 'RadarForbiddenError';\n        this.code = 403;\n        this.response = response;\n        this.status = 'ERROR_FORBIDDEN';\n    }\n}\nclass RadarNotFoundError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Not found.');\n        this.name = 'RadarNotFoundError';\n        this.code = 404;\n        this.response = response;\n        this.status = 'ERROR_NOT_FOUND';\n    }\n}\nclass RadarRateLimitError extends RadarError {\n    constructor(response) {\n        var _a, _b;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Rate limit exceeded.');\n        this.name = 'RadarRateLimitError';\n        this.code = 429;\n        this.response = response;\n        this.type = (_b = response === null || response === void 0 ? void 0 : response.meta) === null || _b === void 0 ? void 0 : _b.type;\n        this.status = 'ERROR_RATE_LIMIT';\n    }\n}\nclass RadarServerError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Internal server error.');\n        this.name = 'RadarServerError';\n        this.response = response;\n        this.status = 'ERROR_SERVER';\n    }\n}\nclass RadarNetworkError extends RadarError {\n    constructor() {\n        super('Request timed out.');\n        this.name = 'RadarNetworkError';\n        this.status = 'ERROR_NETWORK';\n    }\n}\nclass RadarUnknownError extends RadarError {\n    constructor(response) {\n        var _a;\n        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Something went wrong.');\n        this.name = 'RadarUnknownError';\n        this.response = response;\n        this.status = 'ERROR_UNKNOWN';\n    }\n}\nclass RadarAutocompleteContainerNotFound extends RadarError {\n    constructor(message) {\n        super(message);\n        this.name = 'RadarAutocompleteContainerNotFound';\n        this.status = 'CONTAINER_NOT_FOUND';\n    }\n}\n\nconst DEFAULT_POSITION_OPTIONS = {\n    maximumAge: 0,\n    timeout: 1000 * 30,\n    enableHighAccuracy: true,\n};\n// set \"enableHighAccuracy\" for navigator only when desiredAccuracy is \"high\"\nconst useHighAccuracy = (desiredAccuracy) => (Boolean(desiredAccuracy === 'high'));\nclass Navigator {\n    static getCurrentPosition(overrides = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const options = Config.get();\n                if (!navigator || !navigator.geolocation) {\n                    return reject(new RadarLocationError('navigator.geolocation is not available.'));\n                }\n                // use cached location if available and options are set\n                if (options.cacheLocationMinutes) {\n                    try {\n                        const rawCachedLocation = Storage.getItem(Storage.CACHED_LOCATION);\n                        if (rawCachedLocation) {\n                            const cachedLocation = JSON.parse(rawCachedLocation);\n                            const { latitude, longitude, accuracy, expiresAt } = cachedLocation || {};\n                            if (Date.now() < parseInt(expiresAt)) {\n                                if (latitude && longitude && accuracy) {\n                                    return resolve({ latitude, longitude, accuracy });\n                                }\n                            }\n                        }\n                    }\n                    catch (e) {\n                        Logger.warn('could not load cached location.');\n                    }\n                }\n                // set options from config\n                const positionOptions = Object.assign({}, DEFAULT_POSITION_OPTIONS);\n                if (options.locationMaximumAge !== undefined) {\n                    positionOptions.maximumAge = options.locationMaximumAge;\n                }\n                if (options.locationTimeout !== undefined) {\n                    positionOptions.timeout = options.locationTimeout;\n                }\n                if (options.desiredAccuracy !== undefined) {\n                    positionOptions.enableHighAccuracy = useHighAccuracy(options.desiredAccuracy);\n                }\n                // set options from overrides\n                if (overrides.desiredAccuracy !== undefined) {\n                    positionOptions.enableHighAccuracy = useHighAccuracy(overrides.desiredAccuracy);\n                }\n                Logger.info(`Using geolocation options: ${JSON.stringify(positionOptions)}`);\n                // get current location from browser\n                navigator.geolocation.getCurrentPosition((position) => {\n                    if (!position || !position.coords) {\n                        return reject(new RadarLocationError('device location return empty coordinates.'));\n                    }\n                    const { latitude, longitude, accuracy } = position.coords;\n                    // cache location if option is set\n                    if (options.cacheLocationMinutes) {\n                        const cacheLocationMinutes = Number.parseFloat(options.cacheLocationMinutes);\n                        const updatedAt = Date.now();\n                        const expiresAt = updatedAt + (cacheLocationMinutes * 60 * 1000); // convert to ms\n                        const lastLocation = { latitude, longitude, accuracy, updatedAt, expiresAt };\n                        Storage.setItem(Storage.CACHED_LOCATION, JSON.stringify(lastLocation));\n                    }\n                    return resolve({ latitude, longitude, accuracy });\n                }, (err) => {\n                    if (err && err.code === 1) {\n                        // https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError\n                        // code 1 means location permissions denied\n                        // codes 2 and 3 mean location unavailable or timeout\n                        return reject(new RadarPermissionsError('Location permissions denied.'));\n                    }\n                    return reject(new RadarLocationError('Could not determine location.'));\n                }, positionOptions);\n            });\n        });\n    }\n    static getPermissionStatus() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                if (!navigator || !navigator.permissions) {\n                    return reject(new RadarLocationError('navigator.permissions is not available.'));\n                }\n                navigator.permissions.query({ name: 'geolocation' }).then((permissionsStatus) => {\n                    let locationAuthorization = 'NOT_DETERMINED';\n                    switch (permissionsStatus.state) {\n                        case 'granted':\n                            locationAuthorization = 'GRANTED_FOREGROUND';\n                            break;\n                        case 'denied':\n                            locationAuthorization = 'DENIED';\n                            break;\n                        case 'prompt':\n                            locationAuthorization = 'NOT_DETERMINED';\n                            break;\n                    }\n                    return resolve(locationAuthorization);\n                });\n            });\n        });\n    }\n}\n\nvar SDK_VERSION = '4.4.3';\n\nconst inFlightRequests = new Map();\nclass Http {\n    static request({ method, path, data, host, version, headers = {}, responseType, requestId, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const options = Config.get();\n                // check for publishableKey on request\n                const publishableKey = options.publishableKey;\n                if (!publishableKey) {\n                    reject(new RadarPublishableKeyError('publishableKey not set.'));\n                    return;\n                }\n                // setup request URL\n                const urlHost = host || options.host;\n                const urlVersion = version || options.version;\n                let url = `${urlHost}/${urlVersion}/${path}`;\n                // remove undefined values from request data\n                let body = {};\n                Object.keys(data || {}).forEach((key) => {\n                    const value = data[key];\n                    if (value !== undefined) {\n                        body[key] = value;\n                    }\n                });\n                // convert data to querystring for GET requests\n                if (method === 'GET') {\n                    const params = Object.keys(body).map((key) => (`${key}=${encodeURIComponent(body[key])}`));\n                    if (params.length > 0) {\n                        const queryString = params.join('&');\n                        url = `${url}?${queryString}`;\n                    }\n                    body = undefined; // dont send body for GET request\n                }\n                // check for in-flight requests with matching requestIds\n                if (requestId) {\n                    const request = inFlightRequests.get(requestId);\n                    if (request) {\n                        request.abort(); // abort request\n                    }\n                }\n                const xhr = new XMLHttpRequest();\n                xhr.open(method, url, true);\n                // save reference to request\n                if (requestId) {\n                    inFlightRequests.set(requestId, xhr);\n                }\n                const defaultHeaders = {\n                    'Authorization': publishableKey,\n                    'Content-Type': 'application/json',\n                    'X-Radar-Device-Type': 'Web',\n                    'X-Radar-SDK-Version': SDK_VERSION,\n                };\n                // set custom config headers if present\n                let configHeaders = {};\n                if (typeof options.getRequestHeaders === 'function') {\n                    configHeaders = options.getRequestHeaders();\n                }\n                // combines default headers with custom headers and config headers\n                const allHeaders = Object.assign(defaultHeaders, configHeaders, headers);\n                // set headers\n                Object.keys(allHeaders).forEach((key) => {\n                    xhr.setRequestHeader(key, allHeaders[key]);\n                });\n                if (responseType) {\n                    xhr.responseType = responseType;\n                }\n                xhr.onload = () => {\n                    var _a;\n                    let response;\n                    if (requestId) { // clear in-flight request\n                        inFlightRequests.delete(requestId);\n                    }\n                    try {\n                        if (xhr.responseType === 'blob') {\n                            response = { code: xhr.status, data: xhr.response };\n                        }\n                        else {\n                            response = JSON.parse(xhr.response);\n                        }\n                    }\n                    catch (e) {\n                        return reject(new RadarServerError(response));\n                    }\n                    const error = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.error;\n                    if (error === 'ERROR_PERMISSIONS') {\n                        return reject(new RadarPermissionsError('Location permissions not granted.'));\n                    }\n                    else if (error === 'ERROR_LOCATION') {\n                        return reject(new RadarLocationError('Could not determine location.'));\n                    }\n                    else if (error === 'ERROR_NETWORK') {\n                        return reject(new RadarNetworkError());\n                    }\n                    if (xhr.status == 200) {\n                        return resolve(response);\n                    }\n                    if (options.debug) {\n                        Logger.debug(`API call failed: ${url}`);\n                        Logger.debug(JSON.stringify(response));\n                    }\n                    if (xhr.status === 400) {\n                        reject(new RadarBadRequestError(response));\n                    }\n                    else if (xhr.status === 401) {\n                        reject(new RadarUnauthorizedError(response));\n                    }\n                    else if (xhr.status === 402) {\n                        reject(new RadarPaymentRequiredError(response));\n                    }\n                    else if (xhr.status === 403) {\n                        reject(new RadarForbiddenError(response));\n                    }\n                    else if (xhr.status === 404) {\n                        reject(new RadarNotFoundError(response));\n                    }\n                    else if (xhr.status === 429) {\n                        reject(new RadarRateLimitError(response));\n                    }\n                    else if (500 <= xhr.status && xhr.status < 600) {\n                        reject(new RadarServerError(response));\n                    }\n                    else {\n                        reject(new RadarUnknownError(response));\n                    }\n                };\n                xhr.onerror = function () {\n                    if (host && (host === 'http://localhost:52516' || host === 'https://radar-verify.com:52516')) {\n                        reject(new RadarVerifyAppError());\n                    }\n                    else {\n                        reject(new RadarServerError());\n                    }\n                };\n                xhr.ontimeout = function () {\n                    reject(new RadarVerifyAppError());\n                };\n                xhr.send(JSON.stringify(body));\n            });\n        });\n    }\n}\n\nclass AddressesAPI {\n    static validateAddress(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'addresses/validate',\n                data: params,\n            });\n            const { address, result } = response;\n            const validateAddressRes = {\n                address,\n                result,\n            };\n            if (options.debug) {\n                validateAddressRes.response = response;\n            }\n            return validateAddressRes;\n        });\n    }\n}\n\nconst generateUUID = () => {\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {\n        const r = Math.random() * 16 | 0;\n        const v = (char == 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n    return uuid;\n};\nclass Device {\n    static getDeviceId() {\n        // use existing deviceId if present\n        const deviceId = Storage.getItem(Storage.DEVICE_ID);\n        if (deviceId) {\n            return deviceId;\n        }\n        // generate new deviceId\n        const uuid = generateUUID();\n        Storage.setItem(Storage.DEVICE_ID, uuid);\n        return uuid;\n    }\n    static getInstallId() {\n        // use existing installId if present\n        const deviceId = Storage.getItem(Storage.INSTALL_ID);\n        if (deviceId) {\n            return deviceId;\n        }\n        // generate new installId\n        const uuid = generateUUID();\n        Storage.setItem(Storage.INSTALL_ID, uuid);\n        return uuid;\n    }\n}\n\nconst SESSION_TIMEOUT_SECS = 300; // 5 mins\nconst isValid = (sessionId) => {\n    const now = Math.trunc(Date.now() / 1000);\n    const session = Number.parseInt(sessionId);\n    const diff = Math.abs(now - session);\n    return diff < SESSION_TIMEOUT_SECS;\n};\nclass Session {\n    static getSessionId() {\n        const sessionId = Storage.getItem(Storage.SESSION_ID);\n        // reuse session if still within 5 min threshold\n        if (sessionId && isValid(sessionId)) {\n            return sessionId;\n        }\n        // create new session if does not already exist or expired\n        const newSessionId = Math.trunc(Date.now() / 1000).toString(); // unix ts in seconds\n        Storage.setItem(Storage.SESSION_ID, newSessionId);\n        return newSessionId;\n    }\n}\n\nclass ConfigAPI {\n    static getConfig(params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            if (options.version != 'v1') {\n                Logger.info('Skipping /config call.');\n                return;\n            }\n            const deviceId = params.deviceId || Device.getDeviceId();\n            const installId = params.installId || Device.getInstallId();\n            const sessionId = Session.getSessionId();\n            const locationAuthorization = yield Navigator.getPermissionStatus();\n            const data = {\n                deviceId,\n                installId,\n                sessionId,\n                locationAuthorization,\n            };\n            try {\n                yield Http.request({\n                    method: 'GET',\n                    path: 'config',\n                    data,\n                });\n            }\n            catch (err) {\n                Logger.warn(`Error calling /config: ${err.message}`);\n            }\n        });\n    }\n}\n\nclass ContextAPI {\n    static getContext(location) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            // get device location if coordinates not provided\n            if (!location.latitude || !location.longitude) {\n                location = yield Navigator.getCurrentPosition();\n            }\n            const { latitude, longitude, accuracy } = location;\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'context',\n                data: {\n                    coordinates: `${latitude},${longitude}`,\n                    accuracy,\n                },\n            });\n            const { geofences, place, country, state, dma, postalCode, } = response;\n            const contextRes = {\n                location,\n                geofences,\n                place,\n                country,\n                state,\n                dma,\n                postalCode,\n            };\n            if (options.debug) {\n                contextRes.response = response;\n            }\n            return contextRes;\n        });\n    }\n}\n\nclass ConversionsAPI {\n    static logConversion(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            const name = params.name;\n            const userId = params.userId || Storage.getItem(Storage.USER_ID);\n            const deviceId = params.deviceId || Device.getDeviceId();\n            const installId = params.installId || Device.getInstallId();\n            const metadata = params.metadata || {};\n            const createdAt = params.createdAt;\n            if (params.revenue) {\n                metadata.revenue = params.revenue;\n            }\n            const data = {\n                name,\n                userId,\n                deviceId,\n                installId,\n                metadata,\n            };\n            if (typeof createdAt === 'string') {\n                data.createdAt = createdAt;\n            }\n            else if (createdAt instanceof Date) {\n                data.createdAt = createdAt.toISOString();\n            }\n            else {\n                data.createdAt = (new Date()).toISOString();\n            }\n            const response = yield Http.request({\n                method: 'POST',\n                path: 'events',\n                data,\n            });\n            const conversionRes = {\n                event: response.event,\n            };\n            if (options.debug) {\n                conversionRes.response = response;\n            }\n            return conversionRes;\n        });\n    }\n}\n\nclass Geocoding {\n    static forwardGeocode(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            const { query, layers, country } = params;\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'geocode/forward',\n                data: {\n                    query,\n                    layers,\n                    country,\n                },\n            });\n            const forwardGeocodeRes = {\n                addresses: response.addresses,\n            };\n            if (options.debug) {\n                forwardGeocodeRes.response = response;\n            }\n            return forwardGeocodeRes;\n        });\n    }\n    static reverseGeocode(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { latitude, longitude, layers } = params;\n            if (!latitude || !longitude) {\n                const location = yield Navigator.getCurrentPosition();\n                latitude = location.latitude;\n                longitude = location.longitude;\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'geocode/reverse',\n                data: {\n                    coordinates: `${latitude},${longitude}`,\n                    layers,\n                },\n            });\n            const reverseGeocodeRes = {\n                addresses: response.addresses,\n            };\n            if (options.debug) {\n                reverseGeocodeRes.response = response;\n            }\n            return reverseGeocodeRes;\n        });\n    }\n    static ipGeocode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'geocode/ip',\n            });\n            const ipGeocodeRes = {\n                ip: response.ip,\n                address: response.address,\n                proxy: response.proxy,\n            };\n            if (options.debug) {\n                ipGeocodeRes.response = response;\n            }\n            return ipGeocodeRes;\n        });\n    }\n}\n\nclass RoutingAPI {\n    static distance(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { origin, destination, modes, units, geometry, geometryPoints, avoid, } = params;\n            // use browser location if \"near\" not provided\n            if (!origin) {\n                const { latitude, longitude } = yield Navigator.getCurrentPosition();\n                origin = `${latitude},${longitude}`;\n            }\n            else if (typeof origin !== 'string') { // origin is \"Location\" object\n                const { latitude, longitude } = origin;\n                origin = `${latitude},${longitude}`;\n            }\n            if (typeof destination !== 'string') {\n                const { latitude, longitude } = destination;\n                destination = `${latitude},${longitude}`;\n            }\n            if (Array.isArray(modes)) {\n                modes = modes.join(',');\n            }\n            if (Array.isArray(avoid)) {\n                avoid = avoid.join(',');\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'route/distance',\n                data: {\n                    origin,\n                    destination,\n                    modes,\n                    units,\n                    geometry,\n                    geometryPoints,\n                    avoid,\n                },\n            });\n            const distanceRes = {\n                routes: response.routes,\n            };\n            if (options.debug) {\n                distanceRes.response = response;\n            }\n            return distanceRes;\n        });\n    }\n    static matrix(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { origins, destinations, mode, units, avoid, } = params;\n            // use browser location if \"near\" not provided\n            if (!origins) {\n                const { latitude, longitude } = yield Navigator.getCurrentPosition();\n                let originStrings = [];\n                for (let i = 0; i < destinations.length; i++) {\n                    originStrings.push(`${latitude},${longitude}`);\n                }\n                origins = originStrings.join('|');\n            }\n            else if (Array.isArray(origins)) { // origin is a list of \"Location\" objects\n                origins = origins.map((location) => `${location.latitude},${location.longitude}`).join('|');\n            }\n            // convert array to pipe-delimited string\n            if (Array.isArray(destinations)) {\n                destinations = destinations.map((location) => `${location.latitude},${location.longitude}`).join('|');\n            }\n            if (Array.isArray(avoid)) {\n                avoid = avoid.join(',');\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'route/matrix',\n                data: {\n                    origins,\n                    destinations,\n                    mode,\n                    units,\n                    avoid,\n                },\n            });\n            const matrixRes = {\n                origins: response.origins,\n                destinations: response.destinations,\n                matrix: response.matrix,\n            };\n            if (options.debug) {\n                matrixRes.response = response;\n            }\n            return matrixRes;\n        });\n    }\n}\n\nclass SearchAPI {\n    static autocomplete(params, requestId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { query, near, limit, layers, countryCode, expandUnits, mailable, } = params;\n            // near can be provided as a string or Location object\n            // if \"near\" is not provided, request will fallback to IP based location\n            if (near && typeof near !== 'string') {\n                if (near.latitude && near.longitude) {\n                    near = `${near.latitude},${near.longitude}`;\n                }\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'search/autocomplete',\n                data: {\n                    query,\n                    near,\n                    limit,\n                    layers,\n                    countryCode,\n                    expandUnits,\n                    mailable,\n                },\n                requestId,\n            });\n            const autocompleteRes = {\n                addresses: response.addresses,\n            };\n            if (options.debug) {\n                autocompleteRes.response = response;\n            }\n            return autocompleteRes;\n        });\n    }\n    static searchGeofences(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { near, radius, tags, metadata, limit, includeGeometry, } = params;\n            // use browser location if \"near\" not provided\n            if (!near) {\n                const { latitude, longitude } = yield Navigator.getCurrentPosition();\n                near = `${latitude},${longitude}`;\n            }\n            else if (typeof near !== 'string') { // near is \"Location\" object\n                const { latitude, longitude } = near;\n                near = `${latitude},${longitude}`;\n            }\n            // convert arrays to comma-strings\n            if (Array.isArray(tags)) {\n                tags = tags.join(',');\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'search/geofences',\n                data: {\n                    near,\n                    radius,\n                    tags,\n                    metadata,\n                    limit,\n                    includeGeometry,\n                },\n            });\n            const geofencesSearchRes = {\n                geofences: response.geofences,\n            };\n            if (options.debug) {\n                geofencesSearchRes.response = response;\n            }\n            return geofencesSearchRes;\n        });\n    }\n    static searchPlaces(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { near, radius, chains, categories, groups, limit, } = params;\n            // use browser location if \"near\" not provided\n            if (!near) {\n                const { latitude, longitude } = yield Navigator.getCurrentPosition();\n                near = `${latitude},${longitude}`;\n            }\n            else if (typeof near !== 'string') { // near is \"Location\" object\n                const { latitude, longitude } = near;\n                near = `${latitude},${longitude}`;\n            }\n            // convert arrays to comma-strings\n            if (Array.isArray(chains)) {\n                chains = chains.join(',');\n            }\n            if (Array.isArray(categories)) {\n                categories = categories.join(',');\n            }\n            if (Array.isArray(groups)) {\n                groups = groups.join(',');\n            }\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'search/places',\n                data: {\n                    near,\n                    radius,\n                    chains,\n                    categories,\n                    groups,\n                    limit,\n                },\n            });\n            const placeSearchRes = {\n                places: response.places,\n            };\n            if (options.debug) {\n                placeSearchRes.response = response;\n            }\n            return placeSearchRes;\n        });\n    }\n}\n\n// https://stackoverflow.com/a/44198641\nconst isValidDate = (date) => date && Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date);\nclass TripsAPI {\n    static setTripOptions(tripOptions) {\n        if (!tripOptions) {\n            TripsAPI.clearTripOptions();\n            return;\n        }\n        const tripOptionsString = JSON.stringify(tripOptions);\n        Logger.debug(`Saving trip options: ${tripOptionsString}`);\n        Storage.setItem(Storage.TRIP_OPTIONS, tripOptionsString);\n    }\n    static getTripOptions() {\n        let tripOptions = Storage.getItem(Storage.TRIP_OPTIONS);\n        if (tripOptions) {\n            tripOptions = JSON.parse(tripOptions);\n        }\n        return tripOptions;\n    }\n    static clearTripOptions() {\n        Storage.removeItem(Storage.TRIP_OPTIONS);\n    }\n    static startTrip(tripOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            tripOptions = tripOptions || TripsAPI.getTripOptions();\n            if (!tripOptions) {\n                Logger.warn('tripOptions not set when calling \"startTrip\"');\n            }\n            const userId = tripOptions.userId || Storage.getItem(Storage.USER_ID);\n            if (userId && userId !== Storage.getItem(Storage.USER_ID)) {\n                // set as userId for tracking if provided\n                Storage.setItem(Storage.USER_ID, userId);\n            }\n            const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;\n            const data = {\n                userId,\n                externalId,\n                destinationGeofenceTag,\n                destinationGeofenceExternalId,\n                mode,\n                metadata,\n                approachingThreshold,\n            };\n            if (isValidDate(scheduledArrivalAt)) {\n                data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();\n            }\n            else {\n                if (scheduledArrivalAt) {\n                    Logger.warn('Invalid date format for scheduledArrivalAt');\n                }\n                data.scheduledArrivalAt = undefined;\n            }\n            const response = yield Http.request({\n                method: 'POST',\n                path: 'trips',\n                data,\n            });\n            // save trip options\n            TripsAPI.setTripOptions(tripOptions);\n            const tripRes = {\n                trip: response.trip,\n                events: response.events,\n            };\n            if (options.debug) {\n                tripRes.response = response;\n            }\n            return tripRes;\n        });\n    }\n    static updateTrip(tripOptions, status) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            tripOptions = tripOptions || TripsAPI.getTripOptions();\n            if (!tripOptions) {\n                Logger.warn('tripOptions not set when calling \"startTrip\"');\n            }\n            const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;\n            const data = {\n                status,\n                externalId,\n                destinationGeofenceTag,\n                destinationGeofenceExternalId,\n                mode,\n                metadata,\n                approachingThreshold,\n            };\n            if (isValidDate(scheduledArrivalAt)) {\n                data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();\n            }\n            else {\n                if (scheduledArrivalAt) {\n                    Logger.warn('Invalid date format for scheduledArrivalAt');\n                }\n                data.scheduledArrivalAt = undefined;\n            }\n            const response = yield Http.request({\n                method: 'PATCH',\n                path: `trips/${externalId}/update`,\n                data,\n            });\n            const tripRes = {\n                trip: response.trip,\n                events: response.events,\n            };\n            if (options.debug) {\n                tripRes.response = response;\n            }\n            return tripRes;\n        });\n    }\n    static completeTrip() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tripOptions = TripsAPI.getTripOptions();\n            const tripResponse = yield TripsAPI.updateTrip(tripOptions, 'completed');\n            // clear local trip options\n            TripsAPI.clearTripOptions();\n            return tripResponse;\n        });\n    }\n    static cancelTrip() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tripOptions = TripsAPI.getTripOptions();\n            const tripResponse = yield TripsAPI.updateTrip(tripOptions, 'canceled');\n            // clear local trip options\n            TripsAPI.clearTripOptions();\n            return tripResponse;\n        });\n    }\n}\n\nconst base64Encode = (str) => btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\nconst signJWT = (payload, key) => __awaiter(void 0, void 0, void 0, function* () {\n    const encoder = new TextEncoder();\n    const encodedHeader = base64Encode(JSON.stringify({\n        alg: 'HS256',\n        typ: 'JWT',\n    }));\n    const encodedPayload = base64Encode(JSON.stringify(payload));\n    const keyData = encoder.encode(key);\n    const messageData = encoder.encode(`${encodedHeader}.${encodedPayload}`);\n    const cryptoKey = yield crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n    const signatureArrayBuffer = yield crypto.subtle.sign('HMAC', cryptoKey, messageData);\n    const signature = base64Encode(String.fromCharCode(...Array.from(new Uint8Array(signatureArrayBuffer))));\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n});\n\nconst ping = (host) => {\n    return new Promise((resolve) => {\n        const socket = new WebSocket(host);\n        let pings = 0;\n        const latencies = [];\n        let pingInterval;\n        let timeoutInterval;\n        const ping = () => {\n            pings++;\n            const start = Date.now();\n            socket.send('ping');\n            socket.onmessage = (event) => {\n                if (event.data === 'pong') {\n                    const latency = Date.now() - start;\n                    latencies.push(latency);\n                    if (pings >= 3) {\n                        clearInterval(pingInterval);\n                        clearInterval(timeoutInterval);\n                        const median = latencies.sort((a, b) => a - b)[1];\n                        socket.close();\n                        resolve(median);\n                    }\n                }\n            };\n        };\n        const timeout = () => {\n            Logger.warn('Socket timeout');\n            clearInterval(pingInterval);\n            clearInterval(timeoutInterval);\n            socket.close();\n            resolve(-1);\n        };\n        socket.onerror = (err) => {\n            Logger.warn('Error opening socket');\n            socket.close();\n            resolve(-1);\n        };\n        socket.onopen = () => {\n            ping();\n            pingInterval = setInterval(ping, 1000);\n            timeoutInterval = setInterval(timeout, 10000);\n        };\n    });\n};\n\nclass TrackAPI {\n    static trackOnce(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            let { latitude, longitude, accuracy, desiredAccuracy, fraud } = params;\n            // if latitude & longitude are not provided,\n            // try and retrieve device location (will prompt for location permissions)\n            if (!latitude || !longitude) {\n                const deviceLocation = yield Navigator.getCurrentPosition({ desiredAccuracy });\n                latitude = deviceLocation.latitude;\n                longitude = deviceLocation.longitude;\n                accuracy = deviceLocation.accuracy;\n            }\n            // location authorization\n            let locationAuthorization;\n            try {\n                locationAuthorization = yield Navigator.getPermissionStatus();\n            }\n            catch (err) {\n                Logger.warn(`Location authorization error: ${err.message}`);\n            }\n            // user indentification fields\n            const userId = params.userId || Storage.getItem(Storage.USER_ID);\n            const deviceId = params.deviceId || Device.getDeviceId();\n            const installId = params.installId || Device.getInstallId();\n            const sessionId = Session.getSessionId();\n            const deviceType = params.deviceType || 'Web';\n            const description = params.description || Storage.getItem(Storage.DESCRIPTION);\n            let timeZone;\n            try {\n                timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n            }\n            catch (err) {\n                Logger.warn(`Error getting time zone: ${err.message}`);\n            }\n            // save userId for trip tracking\n            if (!userId) {\n                Logger.warn('userId not provided for trackOnce.');\n            }\n            else {\n                Storage.setItem(Storage.USER_ID, userId);\n            }\n            // other info\n            const metadata = params.metadata || Storage.getJSON(Storage.METADATA);\n            // trips\n            const tripOptions = params.tripOptions || TripsAPI.getTripOptions();\n            if (tripOptions) {\n                tripOptions.version = '2';\n            }\n            const body = Object.assign(Object.assign({}, params), { locationAuthorization,\n                accuracy,\n                description,\n                deviceId,\n                deviceType, foreground: true, installId,\n                sessionId,\n                latitude,\n                longitude,\n                metadata, sdkVersion: SDK_VERSION, stopped: true, userId,\n                tripOptions,\n                timeZone });\n            let response;\n            if (fraud) {\n                const host = 'https://api-verified.radar.io';\n                const pingHost = 'ping.radar-verify.com';\n                const lang = navigator.language;\n                const langs = navigator.languages;\n                const { dk } = yield Http.request({\n                    host,\n                    method: 'GET',\n                    path: 'config',\n                    data: {\n                        deviceId,\n                        installId,\n                        sessionId,\n                        locationAuthorization,\n                    },\n                    headers: {\n                        'X-Radar-Desktop-Device-Type': 'Web',\n                    },\n                });\n                let sclVal = -1;\n                let cslVal = -1;\n                try {\n                    const [sclRes, csl] = yield Promise.all([\n                        Http.request({\n                            host: `https://${pingHost}`,\n                            method: 'GET',\n                            path: 'ping',\n                        }),\n                        ping(`wss://${pingHost}`),\n                    ]);\n                    const { scl } = sclRes;\n                    sclVal = scl;\n                    cslVal = csl;\n                }\n                catch (err) {\n                    // do nothing, send scl = -1 and csl = -1\n                }\n                const payload = {\n                    payload: JSON.stringify(Object.assign(Object.assign({}, body), { scl: sclVal, csl: cslVal, lang,\n                        langs })),\n                };\n                const reqToken = yield signJWT(payload, dk);\n                response = yield Http.request({\n                    host,\n                    method: 'POST',\n                    path: 'track',\n                    data: {\n                        token: reqToken,\n                    },\n                    headers: {\n                        'X-Radar-Body-Is-Token': 'true',\n                    },\n                });\n                if (options.debug && response && response.user) {\n                    if (!response.user.metadata) {\n                        response.user.metadata = {};\n                    }\n                    response.user.metadata['radar:debug'] = {\n                        sclVal,\n                        cslVal,\n                    };\n                }\n                let { user, events, token, expiresAt, expiresIn, passed, failureReasons, _id } = response;\n                const location = { latitude, longitude, accuracy };\n                if (expiresAt) {\n                    expiresAt = new Date(expiresAt);\n                }\n                const trackRes = {\n                    user,\n                    events,\n                    location,\n                    token,\n                    expiresAt,\n                    expiresIn,\n                    passed,\n                    failureReasons,\n                    _id,\n                };\n                if (options.debug) {\n                    trackRes.response = response;\n                }\n                return trackRes;\n            }\n            response = yield Http.request({\n                method: 'POST',\n                path: 'track',\n                data: body,\n            });\n            const { user, events } = response;\n            const location = { latitude, longitude, accuracy };\n            const trackRes = {\n                user,\n                events,\n                location,\n            };\n            if (options.debug) {\n                trackRes.response = response;\n            }\n            return trackRes;\n        });\n    }\n}\n\nlet tokenTimeoutId = null;\nlet tokenCallback = null;\nlet lastToken = null;\nlet lastTokenNow = 0;\nlet expectedCountryCode = null;\nlet expectedStateCode = null;\nclass VerifyAPI {\n    static trackVerified(params, encrypted = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = Config.get();\n            // user indentification fields\n            const userId = params.userId || Storage.getItem(Storage.USER_ID);\n            const deviceId = params.deviceId || Device.getDeviceId();\n            const installId = params.installId || Device.getInstallId();\n            const sessionId = Session.getSessionId();\n            const description = params.description || Storage.getItem(Storage.DESCRIPTION);\n            // save userId\n            if (!userId) {\n                Logger.warn('userId not provided for trackVerified.');\n            }\n            else {\n                Storage.setItem(Storage.USER_ID, userId);\n            }\n            // other info\n            const metadata = params.metadata || Storage.getJSON(Storage.METADATA);\n            const body = Object.assign(Object.assign({}, params), { description,\n                deviceId, foreground: true, installId,\n                sessionId,\n                metadata, sdkVersion: SDK_VERSION, stopped: true, userId,\n                encrypted,\n                expectedCountryCode,\n                expectedStateCode });\n            let userAgent = navigator.userAgent;\n            const apple = userAgent && (userAgent.toLowerCase().includes('mac') || userAgent.toLowerCase().includes('iphone') || userAgent.toLowerCase().includes('ipod') || userAgent.toLowerCase().includes('ipad'));\n            const response = yield Http.request({\n                method: 'GET',\n                path: 'verify',\n                data: body,\n                host: apple ? 'https://radar-verify.com:52516' : 'http://localhost:52516',\n            });\n            let { user, events, token, expiresAt, expiresIn, passed, failureReasons, _id } = response;\n            let location;\n            if (user && user.location && user.location.coordinates && user.locationAccuracy) {\n                location = {\n                    latitude: user.location.coordinates[1],\n                    longitude: user.location.coordinates[0],\n                    accuracy: user.locationAccuracy,\n                };\n            }\n            if (expiresAt) {\n                expiresAt = new Date(expiresAt);\n            }\n            const trackRes = {\n                user,\n                events,\n                location,\n                token,\n                expiresAt,\n                expiresIn,\n                passed,\n                failureReasons,\n                _id,\n            };\n            if (options.debug) {\n                trackRes.response = response;\n            }\n            lastToken = trackRes;\n            lastTokenNow = performance.now();\n            if (tokenCallback) {\n                tokenCallback(trackRes);\n            }\n            return trackRes;\n        });\n    }\n    static startTrackingVerified(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doTrackVerified = () => __awaiter(this, void 0, void 0, function* () {\n                const trackRes = yield this.trackVerified({});\n                const { interval } = params;\n                let expiresIn = 0;\n                let minInterval = interval;\n                if (trackRes) {\n                    expiresIn = (trackRes.expiresIn || expiresIn);\n                    // if expiresIn is shorter than interval, override interval\n                    minInterval = Math.min(expiresIn, interval);\n                }\n                // re-request early to maximize the likelihood that a cached token is available\n                if (minInterval > 20) {\n                    minInterval = minInterval - 10;\n                }\n                // min interval is 10 seconds\n                if (minInterval < 10) {\n                    minInterval = 10;\n                }\n                if (tokenTimeoutId) {\n                    clearTimeout(tokenTimeoutId);\n                }\n                tokenTimeoutId = setTimeout(doTrackVerified, minInterval * 1000);\n            });\n            doTrackVerified();\n        });\n    }\n    static stopTrackingVerified() {\n        if (tokenTimeoutId) {\n            clearTimeout(tokenTimeoutId);\n        }\n    }\n    static getVerifiedLocationToken() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const lastTokenElapsed = (performance.now() - lastTokenNow) / 1000;\n            if (lastToken) {\n                if (lastTokenElapsed < (lastToken.expiresIn || 0)) {\n                    return lastToken;\n                }\n            }\n            return this.trackVerified({});\n        });\n    }\n    static setExpectedJurisdiction(countryCode, stateCode) {\n        expectedCountryCode = countryCode || null;\n        expectedStateCode = stateCode || null;\n    }\n    static onTokenUpdated(callback) {\n        tokenCallback = callback;\n    }\n}\n\nconst isSecretKey = (key) => (key.includes('_sk_'));\nconst isLiveKey = (key) => (key.includes('_live_'));\nlet Radar$1 = class Radar {\n    static get VERSION() {\n        return SDK_VERSION;\n    }\n    static initialize(publishableKey, options = {}) {\n        if (!publishableKey) {\n            throw new RadarPublishableKeyError('Publishable key required in initialization.');\n        }\n        if (isSecretKey(publishableKey)) {\n            throw new RadarPublishableKeyError('Secret keys are not allowed. Please use your Radar publishable key.');\n        }\n        // store settings in global config\n        const live = isLiveKey(publishableKey);\n        const logLevel = live ? 'error' : 'info';\n        const debug = !live;\n        const radarOptions = Object.assign(Config.defaultOptions, {\n            publishableKey,\n            live,\n            logLevel,\n            debug,\n        }, options);\n        Config.setup(radarOptions);\n        Logger.info(`initialized with ${live ? 'live' : 'test'} publishableKey.`);\n        if (options.debug) {\n            Logger.info(`using options: ${JSON.stringify(options)}`);\n        }\n        // NOTE(jasonl): this allows us to run jest tests\n        // without having to mock the ConfigAPI.getConfig call\n        if (!(window === null || window === void 0 ? void 0 : window.RADAR_TEST_ENV)) {\n            ConfigAPI.getConfig();\n        }\n    }\n    static clear() {\n        Config.clear();\n    }\n    ///////////////////////\n    // Geofencing Platform\n    ///////////////////////\n    static setUserId(userId) {\n        if (!userId) {\n            Storage.removeItem(Storage.USER_ID);\n            return;\n        }\n        Storage.setItem(Storage.USER_ID, String(userId).trim());\n    }\n    static setDescription(description) {\n        if (!description) {\n            Storage.removeItem(Storage.DESCRIPTION);\n            return;\n        }\n        Storage.setItem(Storage.DESCRIPTION, String(description).trim());\n    }\n    static setMetadata(metadata) {\n        if (!metadata) {\n            Storage.removeItem(Storage.METADATA);\n            return;\n        }\n        Storage.setItem(Storage.METADATA, JSON.stringify(metadata));\n    }\n    static getLocation() {\n        return Navigator.getCurrentPosition();\n    }\n    static trackOnce(params = {}) {\n        try {\n            return TrackAPI.trackOnce(params);\n        }\n        finally {\n            ConfigAPI.getConfig(params); // call with updated permissions\n        }\n    }\n    static trackVerified(params = {}) {\n        return VerifyAPI.trackVerified(params);\n    }\n    static startTrackingVerified(params) {\n        return VerifyAPI.startTrackingVerified(params);\n    }\n    static stopTrackingVerified() {\n        return VerifyAPI.stopTrackingVerified();\n    }\n    static getVerifiedLocationToken() {\n        return VerifyAPI.getVerifiedLocationToken();\n    }\n    static setExpectedJurisdiction(countryCode, stateCode) {\n        VerifyAPI.setExpectedJurisdiction(countryCode, stateCode);\n    }\n    static getContext(params) {\n        return ContextAPI.getContext(params);\n    }\n    static setTripOptions(tripOptions) {\n        TripsAPI.setTripOptions(tripOptions);\n    }\n    static clearTripOptions() {\n        TripsAPI.clearTripOptions();\n    }\n    static getTripOptions() {\n        return TripsAPI.getTripOptions();\n    }\n    static startTrip(tripOptions) {\n        return TripsAPI.startTrip(tripOptions);\n    }\n    static updateTrip(tripOptions) {\n        return TripsAPI.updateTrip(tripOptions);\n    }\n    static completeTrip() {\n        return TripsAPI.completeTrip();\n    }\n    static cancelTrip() {\n        return TripsAPI.cancelTrip();\n    }\n    static logConversion(params) {\n        return ConversionsAPI.logConversion(params);\n    }\n    ///////////////////////\n    // Listeners\n    ///////////////////////\n    static onTokenUpdated(callback) {\n        VerifyAPI.onTokenUpdated(callback);\n    }\n    /////////////////\n    // Maps Platform\n    /////////////////\n    static forwardGeocode(params) {\n        return Geocoding.forwardGeocode(params);\n    }\n    static reverseGeocode(params) {\n        return Geocoding.reverseGeocode(params);\n    }\n    static ipGeocode() {\n        return Geocoding.ipGeocode();\n    }\n    static autocomplete(params) {\n        return SearchAPI.autocomplete(params);\n    }\n    static searchGeofences(params) {\n        return SearchAPI.searchGeofences(params);\n    }\n    static searchPlaces(params) {\n        return SearchAPI.searchPlaces(params);\n    }\n    static validateAddress(params) {\n        return AddressesAPI.validateAddress(params);\n    }\n    static distance(params) {\n        return RoutingAPI.distance(params);\n    }\n    static matrix(params) {\n        return RoutingAPI.matrix(params);\n    }\n};\n\nclass RadarFeatureMouseEvent {\n    constructor(type, feature, originalEvent) {\n        this.type = type;\n        this.feature = feature;\n        this.originalEvent = originalEvent;\n    }\n}\nclass RadarMapFeature {\n    constructor(map, feature) {\n        var _a;\n        this._sourceIds = [];\n        this._layerIds = [];\n        this.id = ((_a = feature.id) !== null && _a !== void 0 ? _a : `feature-${Date.now()}`).toString();\n        // check for duplicate IDs\n        (map.getFeatures() || []).forEach((feature) => {\n            if (feature.id === this.id) {\n                throw new Error(`RadarMapFeature: feature with id ${this.id} already exists.`);\n            }\n        });\n        this.geometry = feature.geometry;\n        this.properties = feature.properties || {};\n        this._feature = feature;\n        this._map = map;\n    }\n    remove() {\n        // remove layers\n        this._layerIds.forEach((layerId) => {\n            if (this._map.getLayer(layerId)) {\n                this._map.removeLayer(layerId);\n            }\n        });\n        // remove source\n        this._sourceIds.forEach((sourceId) => {\n            if (this._map.getSource(sourceId)) {\n                this._map.removeSource(sourceId);\n            }\n        });\n        // remove reference from map\n        this._map._features = this._map._features.filter((other) => other.id !== this.id);\n    }\n    // register events with feature layer\n    on(eventType, callback) {\n        this._map.on(eventType, this.id, (event) => {\n            callback(new RadarFeatureMouseEvent(eventType, this, event));\n        });\n        // add pointer cursor if feature is clickable\n        if (eventType === 'click') {\n            this._map.on('mouseenter', this.id, () => {\n                this._map.getCanvas().style.cursor = 'pointer';\n            });\n            this._map.on('mouseleave', this.id, () => {\n                this._map.getCanvas().style.cursor = '';\n            });\n        }\n    }\n}\n\n/**\n * https://github.com/mapbox/polyline\n *\n * Decodes to a [longitude, latitude] coordinates array.\n *\n * This is adapted from the implementation in Project-OSRM.\n *\n * see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n *\n */\nconst decodePolyline = (str, precision = 6) => {\n    let index = 0;\n    let lat = 0;\n    let lng = 0;\n    let coordinates = [];\n    let shift = 0;\n    let result = 0;\n    let byte = null;\n    let latitudeChange;\n    let longitudeChange;\n    let factor = Math.pow(10, precision || 6);\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n        latitudeChange = result & 1 ? ~(result >> 1) : result >> 1;\n        shift = result = 0;\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n        longitudeChange = result & 1 ? ~(result >> 1) : result >> 1;\n        lat += latitudeChange;\n        lng += longitudeChange;\n        coordinates.push([lng / factor, lat / factor]);\n    }\n    return coordinates;\n};\n\n// remove fields with undefined values from object\n// (top-level only)\nconst filterUndefined = (object) => {\n    const obj = {};\n    Object.entries(object).forEach(([key, value]) => {\n        if (value !== undefined) {\n            obj[key] = value;\n        }\n    });\n    return obj;\n};\n// deep merge nested objects - returns a new object\n// (arrays are concatenated)\nconst mergeDeep = (target, source = {}) => {\n    let output = Object.assign({}, target);\n    for (const key in source) {\n        if (source[key] instanceof Object && !Array.isArray(source[key]) && key in target) {\n            output[key] = mergeDeep(target[key], source[key]);\n        }\n        else if (Array.isArray(source[key]) && Array.isArray(target[key])) {\n            output[key] = target[key].concat(source[key]);\n        }\n        else {\n            output[key] = source[key];\n        }\n    }\n    return output;\n};\n\nconst defaultLineOptions = {\n    paint: {\n        'line-cap': 'round',\n        'line-color': '#000257',\n        'line-width': 4,\n        'border-color': '#FFFFFF',\n        'border-width': 2,\n    }\n};\nclass RadarLineFeature extends RadarMapFeature {\n    constructor(map, feature, lineOptions) {\n        super(map, feature);\n        const featureId = this.id;\n        const options = mergeDeep(defaultLineOptions, lineOptions);\n        // use a callback to account for the async loading of the map\n        const addFeatureToMap = () => {\n            options.paint = options.paint || {};\n            // add source for feature\n            map.addSource(featureId, { type: 'geojson', data: feature });\n            this._sourceIds.push(featureId);\n            // add border layer if border styling is present\n            if (options.paint['line-width'] && options.paint['border-width']) {\n                const borderLayerId = `${featureId}-border`;\n                const borderWidth = options.paint['line-width'] + options.paint['border-width'];\n                map.addLayer({\n                    id: borderLayerId,\n                    source: featureId,\n                    type: 'line',\n                    layout: {\n                        'line-cap': options.paint['line-cap'],\n                    },\n                    paint: filterUndefined({\n                        'line-color': options.paint['border-color'],\n                        'line-opacity': options.paint['border-opacity'],\n                        'line-width': borderWidth,\n                    }),\n                });\n                this._layerIds.push(borderLayerId); // border layer\n            }\n            // line-layer\n            map.addLayer({\n                id: featureId,\n                source: featureId,\n                type: 'line',\n                layout: {\n                    'line-cap': options.paint['line-cap'],\n                },\n                paint: filterUndefined({\n                    'line-color': options.paint['line-color'],\n                    'line-width': options.paint['line-width'],\n                    'line-opacity': options.paint['line-opacity'],\n                    'line-offset': options.paint['line-offset'],\n                    'line-blur': options.paint['line-blur'],\n                    'line-dasharray': options.paint['line-dasharray'],\n                    'line-gap-width': options.paint['line-gap-width'],\n                    'line-gradient': options.paint['line-gradient'],\n                }),\n            });\n            this._layerIds.push(featureId); // line layer\n        };\n        // ensure map is ready before modifying source and layers\n        if (map.loaded()) {\n            addFeatureToMap();\n        }\n        else {\n            map.once('data', () => {\n                addFeatureToMap();\n            });\n        }\n        return this;\n    }\n    static fromPolyline(map, polyline, polylineOptions) {\n        const featureId = (polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.id) || `polyline-feature-${Date.now()}`;\n        const coordinates = decodePolyline(polyline, polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.precision);\n        const feature = {\n            id: featureId,\n            type: 'Feature',\n            geometry: {\n                type: 'LineString',\n                coordinates,\n            },\n            properties: (polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.properties) || {},\n        };\n        const lineFeature = new RadarLineFeature(map, feature, polylineOptions);\n        return lineFeature;\n    }\n}\n\nconst defaultPolygonOptions = {\n    paint: {\n        'fill-color': '#FF6F00',\n        'fill-opacity': 0.3,\n        'border-color': '#FF6F00',\n        'border-opacity': 1,\n        'border-width': 2,\n    }\n};\nclass RadarPolygonFeature extends RadarMapFeature {\n    constructor(map, feature, polygonOptions) {\n        super(map, feature);\n        const featureId = this.id;\n        const options = mergeDeep(defaultPolygonOptions, polygonOptions);\n        // use a callback to account for the async loading of the map\n        const addFeatureToMap = () => {\n            options.paint = options.paint || {};\n            // add source for feature\n            map.addSource(featureId, { type: 'geojson', data: feature });\n            this._sourceIds.push(featureId);\n            // polygon-layer\n            map.addLayer({\n                id: featureId,\n                source: featureId,\n                type: 'fill',\n                layout: {},\n                paint: filterUndefined({\n                    'fill-color': options.paint['fill-color'],\n                    'fill-opacity': options.paint['fill-opacity'],\n                }),\n            });\n            this._layerIds.push(featureId);\n            // border layer\n            if (options.paint['border-color'] && options.paint['border-width'] && options.paint['border-opacity']) {\n                let borderLayerId = `${featureId}-border`;\n                map.addLayer({\n                    id: borderLayerId,\n                    source: featureId,\n                    type: 'line',\n                    layout: {},\n                    paint: filterUndefined({\n                        'line-color': options.paint['border-color'],\n                        'line-opacity': options.paint['border-opacity'],\n                        'line-width': options.paint['border-width'],\n                    }),\n                });\n                this._layerIds.push(borderLayerId);\n            }\n        };\n        // ensure map is ready before modifying source and layers\n        if (map.loaded()) {\n            addFeatureToMap();\n        }\n        else {\n            map.once('data', () => {\n                addFeatureToMap();\n            });\n        }\n        return this;\n    }\n}\n\nconst RADAR_LOGO_URL = 'https://api.radar.io/maps/static/images/logo.svg';\nclass RadarLogoControl {\n    onAdd() {\n        const img = document.createElement('img');\n        img.src = RADAR_LOGO_URL;\n        img.alt = 'Radar Maps Platform';\n        this.link = document.createElement('a');\n        this.link.id = 'radar-map-logo';\n        this.link.href = 'https://radar.com?ref=powered_by_radar';\n        this.link.target = '_blank';\n        this.link.appendChild(img);\n        return this.link;\n    }\n    onRemove() {\n        var _a;\n        (_a = this.link) === null || _a === void 0 ? void 0 : _a.remove();\n    }\n}\n\nconst append = (dest, src) => {\n    src.forEach((coord) => {\n        dest.push(coord);\n    });\n};\n// return array of all coordinates in a feature\nconst getCoords = (feature) => {\n    const coordinates = [];\n    const geometry = feature.geometry;\n    switch (geometry.type) {\n        case 'Point':\n            coordinates.push(geometry.coordinates);\n            break;\n        case 'MultiPoint':\n        case 'LineString':\n            append(coordinates, geometry.coordinates);\n            break;\n        case 'MultiLineString':\n        case 'Polygon':\n            geometry.coordinates.forEach(coords => append(coordinates, coords));\n            break;\n        case 'MultiPolygon':\n            geometry.coordinates.forEach(polygon => {\n                polygon.forEach(coords => append(coordinates, coords));\n            });\n            break;\n        default:\n            return coordinates;\n    }\n    return coordinates;\n};\n// return all coordinates from a list of feature\nconst getAllCoords = (features) => {\n    const coordinates = [];\n    (features || []).forEach((feature) => {\n        const coords = getCoords(feature);\n        coords.forEach((coord) => {\n            coordinates.push(coord);\n        });\n    });\n    return coordinates;\n};\n\nconst DEFAULT_STYLE = 'radar-default-v1';\nconst RADAR_STYLES = [\n    'radar-default-v1',\n    'radar-light-v1',\n    'radar-dark-v1',\n];\n// Radar specific configs\nconst defaultRadarMapOptions = {\n    showZoomControls: true,\n};\nconst defaultMaplibreOptions = {\n    minZoom: 1,\n    maxZoom: 20,\n    attributionControl: false,\n    dragRotate: false,\n    touchPitch: false,\n    maplibreLogo: false,\n};\nconst defaultFitMarkersOptions = {\n    padding: 50,\n};\nconst createStyleURL = (options, mapOptions) => {\n    const style = mapOptions.style || DEFAULT_STYLE;\n    let url = `${options.host}/maps/styles/${style}`;\n    if (mapOptions.language) {\n        url += `?language=${mapOptions.language}`;\n    }\n    return url;\n};\n// check if style is a Radar style or a custom style\nconst isRadarStyle = (style) => {\n    if (RADAR_STYLES.includes(style)) { // Radar built-in style\n        return true;\n    }\n    if (!/^(http:|https:)/.test(style)) { // Radar custom style (not a URL)\n        return true;\n    }\n    return false;\n};\n// use formatted style URL if using one of Radar's out-of-the-box styles or is a Radar custom style\nconst getStyle = (options, mapOptions) => {\n    const style = mapOptions.style;\n    if (!style || (typeof style === 'string' && isRadarStyle(style))) {\n        return createStyleURL(options, mapOptions);\n    }\n    return mapOptions.style; // style object or URL\n};\nclass RadarMap extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map {\n    constructor(radarMapOptions) {\n        const config = Config.get();\n        if (!config.publishableKey) {\n            Logger.warn('publishableKey not set. Call Radar.initialize() with key before creating a new map.');\n        }\n        // configure map options\n        const style = getStyle(config, radarMapOptions);\n        const mapOptions = Object.assign({}, defaultRadarMapOptions, defaultMaplibreOptions, radarMapOptions, { style });\n        Logger.debug(`initialize map with options: ${JSON.stringify(mapOptions)}`);\n        mapOptions.transformRequest = (url, resourceType) => {\n            // this handles when a style is switched\n            if (resourceType === 'Style' && isRadarStyle(url)) {\n                url = createStyleURL(config, Object.assign(Object.assign({}, mapOptions), { style: url }));\n            }\n            let headers = {\n                'Authorization': config.publishableKey,\n                'X-Radar-Device-Type': 'Web',\n                'X-Radar-SDK-Version': SDK_VERSION,\n            };\n            if (typeof config.getRequestHeaders === 'function') {\n                headers = Object.assign(headers, config.getRequestHeaders());\n            }\n            return { url, headers };\n        };\n        super(mapOptions); // initialize MapLibre instance\n        this._markers = [];\n        this._features = [];\n        const container = this.getContainer();\n        if (!container.style.width && !container.style.height) {\n            Logger.warn('map container does not have a set \"width\" or \"height\"');\n        }\n        // add radar logo\n        const radarLogo = new RadarLogoControl();\n        this.addControl(radarLogo, 'bottom-left');\n        // add attribution\n        const attribution = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl({ compact: false });\n        this.addControl(attribution, 'bottom-right');\n        // add zoom controls\n        const nav = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl({\n            showCompass: false,\n            showZoom: mapOptions.showZoomControls,\n        });\n        this.addControl(nav, 'bottom-right');\n        // handle map resize actions\n        const onResize = () => {\n            const attrib = document.querySelector('.maplibregl-ctrl-attrib');\n            if (attrib) {\n                const width = this.getContainer().clientWidth;\n                if (width < 380) {\n                    attrib.classList.add('hidden');\n                }\n                else {\n                    attrib.classList.remove('hidden');\n                }\n            }\n        };\n        this.on('resize', onResize);\n        this.on('load', onResize);\n    }\n    addMarker(marker) {\n        this._markers.push(marker);\n    }\n    removeMarker(marker) {\n        this._markers = this._markers.filter((mapMarker) => mapMarker !== marker);\n    }\n    getMarkers() {\n        return this._markers;\n    }\n    fitToMarkers(fitBoundsOptions = {}, overrideMarkers) {\n        const markers = overrideMarkers || this.getMarkers();\n        if (markers.length === 0) {\n            return;\n        }\n        const bounds = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds();\n        markers.forEach((marker) => {\n            bounds.extend(marker.getLngLat());\n        });\n        const options = Object.assign(defaultFitMarkersOptions, fitBoundsOptions);\n        this.fitBounds(bounds, options);\n    }\n    clearMarkers() {\n        this._markers.forEach((marker) => {\n            marker.remove();\n        });\n    }\n    getFeatures() {\n        return this._features;\n    }\n    fitToFeatures(fitBoundsOptions = {}, overrideFeatures) {\n        const features = (overrideFeatures || this._features).map((mapFeature) => mapFeature._feature);\n        const coords = getAllCoords(features);\n        if (coords.length > 0) {\n            const bounds = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds();\n            coords.forEach((coord) => {\n                bounds.extend(coord);\n            });\n            this.fitBounds(bounds, fitBoundsOptions);\n        }\n    }\n    // remove all features from the map\n    clearFeatures() {\n        this._features.forEach((feature) => {\n            feature.remove();\n        });\n    }\n    addPolygon(polygon, polygonOptions) {\n        const feature = new RadarPolygonFeature(this, polygon, polygonOptions);\n        this._features.push(feature);\n        return feature;\n    }\n    addLine(line, lineOptions) {\n        const feature = new RadarLineFeature(this, line, lineOptions);\n        this._features.push(feature);\n        return feature;\n    }\n    addPolyline(polyline, polylineOptions) {\n        const feature = RadarLineFeature.fromPolyline(this, polyline, polylineOptions);\n        this._features.push(feature);\n        return feature;\n    }\n}\n\nclass RadarMarkerMouseEvent {\n    constructor(type, marker, originalEvent) {\n        this.target = marker;\n        this.originalEvent = originalEvent;\n        this.point = marker._pos;\n        this.lngLat = marker.getLngLat();\n        this.type = type;\n    }\n}\n// cache URL loaded markers\nconst IMAGE_CACHE = new Map();\nconst useCachedImage = (url, timeoutMS = 5000) => new Promise((resolve, reject) => {\n    if (!IMAGE_CACHE.has(url)) { // nothing in cache\n        IMAGE_CACHE.set(url, 'pending'); // request in flight\n        return reject('miss');\n    }\n    const start = Date.now();\n    const interval = setInterval(() => {\n        const cachedData = IMAGE_CACHE.get(url);\n        if (cachedData === 'pending') {\n            if ((Date.now() - start) > timeoutMS) { // cache lookup took too long\n                clearInterval(interval);\n                reject('timed out');\n            }\n        }\n        else if (cachedData === 'failed') { // request failed\n            clearInterval(interval);\n            reject('failed');\n        }\n        else if (cachedData !== undefined) { // return data\n            clearInterval(interval);\n            resolve(cachedData);\n        }\n    }, 100);\n});\nconst createImageElement = (options) => {\n    const element = document.createElement('img');\n    element.src = options.url;\n    if (options.width) {\n        if (typeof options.width === 'number') {\n            element.width = options.width;\n        }\n        else {\n            element.style.width = options.width;\n        }\n    }\n    if (options.height) {\n        if (typeof options.height === 'number') {\n            element.height = options.height;\n        }\n        else {\n            element.style.height = options.height;\n        }\n    }\n    if (!options.width && !options.height) {\n        element.style.maxWidth = '64px';\n        element.style.maxHeight = '64px';\n        element.style.width = '100%';\n        element.style.height = '100%';\n    }\n    return element;\n};\nconst defaultMarkerOptions = {\n    color: '#000257',\n};\nclass RadarMarker extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker {\n    constructor(markerOptions) {\n        const maplibreOptions = Object.assign({}, defaultMarkerOptions);\n        // init MapLibre marker configs\n        if (markerOptions.color) {\n            maplibreOptions.color = markerOptions.color;\n        }\n        if (markerOptions.element) {\n            maplibreOptions.element = markerOptions.element;\n        }\n        if (markerOptions.scale) {\n            maplibreOptions.scale = markerOptions.scale;\n        }\n        super(maplibreOptions);\n        // handle marker images (Radar marker, or custom URL)\n        if (markerOptions.marker || markerOptions.url) {\n            const originalElement = this._element.cloneNode(true);\n            this._element.childNodes.forEach((child) => {\n                child.remove();\n            });\n            const onSuccess = (url) => {\n                this._element.replaceChildren(createImageElement({\n                    width: markerOptions.width,\n                    height: markerOptions.height,\n                    url,\n                }));\n            };\n            const onError = (err) => {\n                Logger.error(`Could not load marker: ${err.message} - falling back to default marker`);\n                IMAGE_CACHE.set(markerOptions.url, 'failed'); // mark as failed\n                this._element.replaceChildren(...Array.from(originalElement.childNodes));\n            };\n            // custom URL image\n            if (markerOptions.url) {\n                const loadImage = () => {\n                    fetch(markerOptions.url)\n                        .then(res => {\n                        if (res.status === 200) {\n                            res.blob()\n                                .then((data) => {\n                                const url = URL.createObjectURL(data);\n                                IMAGE_CACHE.set(markerOptions.url, url); // cache data\n                                onSuccess(url);\n                            })\n                                .catch(onError);\n                        }\n                        else {\n                            onError(new Error(res.statusText));\n                        }\n                    })\n                        .catch(onError);\n                };\n                // attempt to use cached data, otherwise fetch marker image data from URL\n                useCachedImage(markerOptions.url)\n                    .then(onSuccess)\n                    .catch((reason) => {\n                    if (reason !== 'miss') {\n                        Logger.debug(`RadarMarker: cache lookup for ${markerOptions.url}: ${reason}`);\n                    }\n                    loadImage();\n                });\n            }\n            // Radar hosted image\n            if (markerOptions.marker) {\n                const loadMarker = () => {\n                    Http.request({\n                        method: 'GET',\n                        version: 'maps',\n                        path: `markers/${markerOptions.marker}`,\n                        responseType: 'blob',\n                    })\n                        .then(({ data }) => {\n                        const url = URL.createObjectURL(data);\n                        IMAGE_CACHE.set(markerOptions.marker, url); // cache data\n                        onSuccess(url);\n                    })\n                        .catch(onError);\n                };\n                useCachedImage(markerOptions.marker)\n                    .then(onSuccess)\n                    .catch((reason) => {\n                    if (reason !== 'miss') {\n                        Logger.debug(`RadarMarker: cache lookup for ${markerOptions.marker} ${reason}`);\n                    }\n                    loadMarker();\n                });\n            }\n        }\n        // handle deprecated popup options\n        if (markerOptions.text) {\n            Logger.warn('marker option \"text\" is deprecated, and will be removed in a future version. Use \"popup.text\".');\n            markerOptions.popup = markerOptions.popup || {};\n            markerOptions.popup.text = markerOptions.text;\n        }\n        if (markerOptions.html) {\n            Logger.warn('marker option \"html\" is deprecated, and will be removed in a future version. Use \"popup.html\".');\n            markerOptions.popup = markerOptions.popup || {};\n            markerOptions.popup.html = markerOptions.html;\n        }\n        // set popup text or HTML\n        if (markerOptions.popup) {\n            const popup = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup(markerOptions.popup);\n            if (markerOptions.popup.text) {\n                popup.setText(markerOptions.popup.text);\n            }\n            if (markerOptions.popup.html) {\n                popup.setHTML(markerOptions.popup.html);\n            }\n            if (markerOptions.popup.element) {\n                popup.setDOMContent(markerOptions.popup.element);\n            }\n            this.setPopup(popup);\n        }\n        // pass-through click event from element to marker\n        const element = this.getElement();\n        if (element) {\n            element.addEventListener('click', (e) => {\n                e.stopPropagation(); // prevent clicks from propagating to map\n                // since we're stopping the propagation to map,\n                // we need to manually toggle the popup associated with the marker\n                if (this.getPopup()) {\n                    // close any other open popups\n                    (this._map.getMarkers() || []).forEach((otherMarker) => {\n                        var _a;\n                        if ((_a = otherMarker.getPopup()) === null || _a === void 0 ? void 0 : _a.isOpen()) {\n                            otherMarker.togglePopup();\n                        }\n                    });\n                    this.togglePopup();\n                }\n                this.fire('click', new RadarMarkerMouseEvent('click', this, e));\n            });\n        }\n    }\n    addTo(map) {\n        map.addMarker(this);\n        return super.addTo(map);\n    }\n    remove() {\n        if (this._map) {\n            this._map.removeMarker(this);\n        }\n        return super.remove();\n    }\n}\n\nclass RadarPopup extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup {\n    constructor(popupOptions) {\n        super(popupOptions);\n        if (popupOptions.text) {\n            this.setText(popupOptions.text);\n        }\n        if (popupOptions.html) {\n            this.setHTML(popupOptions.html);\n        }\n        if (popupOptions.element) {\n            this.setDOMContent(popupOptions.element);\n        }\n    }\n}\n\nclass MapUI {\n    static getMapLibre() {\n        return maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\n    }\n    static createMap(mapOptions) {\n        const radarMap = new RadarMap(mapOptions);\n        return radarMap;\n    }\n    static createMarker(markerOptions = {}) {\n        const radarMarker = new RadarMarker(markerOptions);\n        return radarMarker;\n    }\n    static createPopup(popupOptions) {\n        const popup = new RadarPopup(popupOptions);\n        return popup;\n    }\n}\n\nconst CLASSNAMES = {\n    WRAPPER: 'radar-autocomplete-wrapper',\n    INPUT: 'radar-autocomplete-input',\n    SEARCH_ICON: 'radar-autocomplete-search-icon',\n    RESULTS_LIST: 'radar-autocomplete-results-list',\n    RESULTS_ITEM: 'radar-autocomplete-results-item',\n    RESULTS_MARKER: 'radar-autocomplete-results-marker',\n    SELECTED_ITEM: 'radar-autocomplete-results-item-selected',\n    POWERED_BY_RADAR: 'radar-powered',\n    NO_RESULTS: 'radar-no-results',\n};\nconst defaultAutocompleteOptions = {\n    container: 'autocomplete',\n    debounceMS: 200,\n    minCharacters: 3,\n    limit: 8,\n    placeholder: 'Search address',\n    responsive: true,\n    disabled: false,\n    showMarkers: true,\n    hideResultsOnBlur: true,\n};\n// determine whether to use px or CSS string\nconst formatCSSValue = (value) => {\n    if (typeof value === 'number') {\n        return `${value}px`;\n    }\n    return value;\n};\nconst DEFAULT_WIDTH = 400;\nconst setWidth = (input, options) => {\n    // if responsive and width is provided, treat it as maxWidth\n    if (options.responsive) {\n        input.style.width = '100%';\n        if (options.width) {\n            input.style.maxWidth = formatCSSValue(options.width);\n        }\n        return;\n    }\n    // if not responsive, set fixed width and unset maxWidth\n    input.style.width = formatCSSValue(options.width || DEFAULT_WIDTH);\n    input.style.removeProperty('max-width');\n};\nconst setHeight = (resultsList, options) => {\n    if (options.maxHeight) {\n        resultsList.style.maxHeight = formatCSSValue(options.maxHeight);\n        resultsList.style.overflowY = 'auto'; /* allow overflow when maxHeight is applied */\n    }\n};\nconst getMarkerIcon = (color = \"#ACBDC8\") => {\n    const fill = color.replace('#', '%23');\n    const svg = `<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.5704 6.57036C12.5704 4.11632 10.6342 2.11257 8.21016 2C8.14262 2 8.06757 2 8.00003 2C7.93249 2 7.85744 2 7.7899 2C5.35838 2.11257 3.42967 4.11632 3.42967 6.57036C3.42967 6.60037 3.42967 6.6379 3.42967 6.66792C3.42967 6.69794 3.42967 6.73546 3.42967 6.76548C3.42967 9.46717 7.09196 13.3621 7.4672 13.7598C7.61729 13.9174 7.84994 14 8.00003 14C8.15012 14 8.38277 13.9174 8.53286 13.7598C8.9156 13.3621 12.5704 9.46717 12.5704 6.76548C12.5704 6.72795 12.5704 6.69794 12.5704 6.66792C12.5704 6.6379 12.5704 6.60037 12.5704 6.57036ZM7.99252 8.28893C7.04693 8.28893 6.27395 7.52345 6.27395 6.57036C6.27395 5.61726 7.03943 4.85178 7.99252 4.85178C8.94562 4.85178 9.7111 5.61726 9.7111 6.57036C9.7111 7.52345 8.94562 8.28893 7.99252 8.28893Z\" fill=\"${fill}\"/>\n  </svg>`.trim();\n    return `data:image/svg+xml;charset=utf-8,${svg}`;\n};\nclass AutocompleteUI {\n    // create a new AutocompleteUI instance\n    static createAutocomplete(autocompleteOptions) {\n        return new AutocompleteUI(autocompleteOptions);\n    }\n    constructor(options = {}) {\n        this.config = Object.assign({}, defaultAutocompleteOptions, options);\n        // setup state\n        this.isOpen = false;\n        this.debouncedFetchResults = this.debounce(this.fetchResults, this.config.debounceMS);\n        this.results = [];\n        this.highlightedIndex = -1;\n        // set threshold alias\n        if (this.config.threshold !== undefined) {\n            this.config.minCharacters = this.config.threshold;\n            Logger.warn('AutocompleteUI option \"threshold\" is deprecated, use \"minCharacters\" instead.');\n        }\n        if (options.near) {\n            if (typeof options.near === 'string') {\n                this.near = options.near;\n            }\n            else {\n                this.near = `${options.near.latitude},${options.near.longitude}`;\n            }\n        }\n        // get container element\n        let containerEL;\n        if (typeof this.config.container === 'string') { // lookup container element by ID\n            containerEL = document.getElementById(this.config.container);\n        }\n        else { // use provided element\n            containerEL = this.config.container; // HTMLElement\n        }\n        if (!containerEL) {\n            throw new RadarAutocompleteContainerNotFound(`Could not find container element: ${this.config.container}`);\n        }\n        this.container = containerEL;\n        // create wrapper for input and result list\n        this.wrapper = document.createElement('div');\n        this.wrapper.classList.add(CLASSNAMES.WRAPPER);\n        this.wrapper.style.display = this.config.responsive ? 'block' : 'inline-block';\n        setWidth(this.wrapper, this.config);\n        // result list element\n        this.resultsList = document.createElement('ul');\n        this.resultsList.classList.add(CLASSNAMES.RESULTS_LIST);\n        this.resultsList.setAttribute('id', CLASSNAMES.RESULTS_LIST);\n        this.resultsList.setAttribute('role', 'listbox');\n        this.resultsList.setAttribute('aria-live', 'polite');\n        this.resultsList.setAttribute('aria-label', 'Search results');\n        setHeight(this.resultsList, this.config);\n        if (containerEL.nodeName === 'INPUT') {\n            // if an <input> element is provided, use that as the inputField,\n            // and append the resultList to it's parent container\n            this.inputField = containerEL;\n            // append to dom\n            this.wrapper.appendChild(this.resultsList);\n            containerEL.parentNode.appendChild(this.wrapper);\n        }\n        else {\n            // if container is not an input, create new input and append to container\n            // create new input\n            this.inputField = document.createElement('input');\n            this.inputField.classList.add(CLASSNAMES.INPUT);\n            this.inputField.placeholder = this.config.placeholder;\n            this.inputField.type = 'text';\n            this.inputField.disabled = this.config.disabled;\n            // search icon\n            const searchIcon = document.createElement('div');\n            searchIcon.classList.add(CLASSNAMES.SEARCH_ICON);\n            // append to DOM\n            this.wrapper.appendChild(this.inputField);\n            this.wrapper.appendChild(this.resultsList);\n            this.wrapper.appendChild(searchIcon);\n            this.container.appendChild(this.wrapper);\n        }\n        // disable browser autofill\n        this.inputField.setAttribute('autocomplete', 'off');\n        // set aria roles\n        this.inputField.setAttribute('role', 'combobox');\n        this.inputField.setAttribute('aria-controls', CLASSNAMES.RESULTS_LIST);\n        this.inputField.setAttribute('aria-expanded', 'false');\n        this.inputField.setAttribute('aria-haspopup', 'listbox');\n        this.inputField.setAttribute('aria-autocomplete', 'list');\n        this.inputField.setAttribute('aria-activedescendant', '');\n        // setup event listeners\n        this.inputField.addEventListener('input', this.handleInput.bind(this));\n        this.inputField.addEventListener('keydown', this.handleKeyboardNavigation.bind(this));\n        if (this.config.hideResultsOnBlur) {\n            this.inputField.addEventListener('blur', this.close.bind(this), true);\n        }\n        Logger.debug(`AutocompleteUI iniailized with options: ${JSON.stringify(this.config)}`);\n    }\n    handleInput() {\n        // Fetch autocomplete results and display them\n        const query = this.inputField.value;\n        if (query.length < this.config.minCharacters) {\n            return;\n        }\n        this.debouncedFetchResults(query)\n            .then((results) => {\n            const onResults = this.config.onResults;\n            if (onResults) {\n                onResults(results);\n            }\n            this.displayResults(results);\n        })\n            .catch((error) => {\n            Logger.warn(`Autocomplete ui error: ${error.message}`);\n            const onError = this.config.onError;\n            if (onError) {\n                onError(error);\n            }\n        });\n    }\n    debounce(fn, delay) {\n        let timeoutId;\n        let resolveFn;\n        let rejectFn;\n        return (...args) => {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => {\n                const result = fn.apply(this, args);\n                if (result instanceof Promise) {\n                    result\n                        .then((value) => {\n                        if (resolveFn) {\n                            resolveFn(value);\n                        }\n                    })\n                        .catch((error) => {\n                        if (rejectFn) {\n                            rejectFn(error);\n                        }\n                    });\n                }\n            }, delay);\n            return new Promise((resolve, reject) => {\n                resolveFn = resolve;\n                rejectFn = reject;\n            });\n        };\n    }\n    fetchResults(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { limit, layers, countryCode, expandUnits, mailable, onRequest } = this.config;\n            const params = {\n                query,\n                limit,\n                layers,\n                countryCode,\n                expandUnits,\n                mailable,\n            };\n            if (this.near) {\n                params.near = this.near;\n            }\n            if (onRequest) {\n                onRequest(params);\n            }\n            const { addresses } = yield SearchAPI.autocomplete(params, 'autocomplete-ui');\n            return addresses;\n        });\n    }\n    displayResults(results) {\n        // Clear the previous results\n        this.clearResultsList();\n        this.results = results;\n        let marker;\n        if (this.config.showMarkers) {\n            marker = document.createElement('img');\n            marker.classList.add(CLASSNAMES.RESULTS_MARKER);\n            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));\n        }\n        // Create and append list items for each result\n        results.forEach((result, index) => {\n            const li = document.createElement('li');\n            li.classList.add(CLASSNAMES.RESULTS_ITEM);\n            li.setAttribute('role', 'option');\n            li.setAttribute('id', `${CLASSNAMES.RESULTS_ITEM}}-${index}`);\n            // construct result with bolded label\n            let listContent;\n            if (result.formattedAddress.includes(result.addressLabel) && result.layer !== 'postalCode') {\n                // if addressLabel is contained in the formatted address, bold the address label\n                const regex = new RegExp(`(${result.addressLabel}),?`);\n                listContent = result.formattedAddress.replace(regex, '<b>$1</b>');\n            }\n            else {\n                // otherwise append the address or place label to formatted address\n                const label = result.placeLabel || result.addressLabel;\n                listContent = `<b>${label}</b> ${result.formattedAddress}`;\n            }\n            li.innerHTML = listContent;\n            // prepend marker if enabled\n            if (marker) {\n                li.prepend(marker.cloneNode());\n            }\n            // add click handler to each result, use mousedown to fire before blur event\n            li.addEventListener('mousedown', () => {\n                this.select(index);\n            });\n            this.resultsList.appendChild(li);\n        });\n        this.open();\n        if (results.length > 0) {\n            const link = document.createElement('a');\n            link.href = 'https://radar.com?ref=powered_by_radar';\n            link.target = '_blank';\n            this.poweredByLink = link;\n            const poweredByText = document.createElement('span');\n            poweredByText.textContent = 'Powered by';\n            link.appendChild(poweredByText);\n            const radarLogo = document.createElement('span');\n            radarLogo.id = 'radar-powered-logo';\n            radarLogo.textContent = 'Radar';\n            link.appendChild(radarLogo);\n            const poweredByContainer = document.createElement('div');\n            poweredByContainer.classList.add(CLASSNAMES.POWERED_BY_RADAR);\n            poweredByContainer.appendChild(link);\n            this.resultsList.appendChild(poweredByContainer);\n        }\n        else {\n            const noResultsText = document.createElement('div');\n            noResultsText.classList.add(CLASSNAMES.NO_RESULTS);\n            noResultsText.textContent = 'No results';\n            this.resultsList.appendChild(noResultsText);\n        }\n    }\n    open() {\n        if (this.isOpen) {\n            return;\n        }\n        this.inputField.setAttribute('aria-expanded', 'true');\n        this.resultsList.removeAttribute('hidden');\n        this.isOpen = true;\n    }\n    close(e) {\n        if (!this.isOpen) {\n            return;\n        }\n        // run this code async to allow link click to propagate before blur\n        // (add 100ms delay if closed from link click)\n        const linkClick = e && (e.relatedTarget === this.poweredByLink);\n        setTimeout(() => {\n            this.inputField.setAttribute('aria-expanded', 'false');\n            this.inputField.setAttribute('aria-activedescendant', '');\n            this.resultsList.setAttribute('hidden', '');\n            this.highlightedIndex = -1;\n            this.isOpen = false;\n            this.clearResultsList();\n        }, linkClick ? 100 : 0);\n    }\n    goTo(index) {\n        if (!this.isOpen || !this.results.length) {\n            return;\n        }\n        // wrap around\n        if (index < 0) {\n            index = this.results.length - 1;\n        }\n        else if (index >= this.results.length) {\n            index = 0;\n        }\n        const resultItems = this.resultsList.getElementsByTagName('li');\n        if (this.highlightedIndex > -1) {\n            // clear class names on previously highlighted item\n            resultItems[this.highlightedIndex].classList.remove(CLASSNAMES.SELECTED_ITEM);\n        }\n        // add class name to newly highlighted item\n        resultItems[index].classList.add(CLASSNAMES.SELECTED_ITEM);\n        // set aria active descendant\n        this.inputField.setAttribute('aria-activedescendant', `${CLASSNAMES.RESULTS_ITEM}-${index}`);\n        this.highlightedIndex = index;\n    }\n    handleKeyboardNavigation(event) {\n        let key = event.key;\n        // allow event to propagate if result list is not open\n        if (!this.isOpen) {\n            return;\n        }\n        // treat shift+tab as up key\n        if (key === 'Tab' && event.shiftKey) {\n            key = 'ArrowUp';\n        }\n        switch (key) {\n            // Next item\n            case 'Tab':\n            case 'ArrowDown':\n                event.preventDefault();\n                this.goTo(this.highlightedIndex + 1);\n                break;\n            // Prev item\n            case 'ArrowUp':\n                event.preventDefault();\n                this.goTo(this.highlightedIndex - 1);\n                break;\n            // Select\n            case 'Enter':\n                this.select(this.highlightedIndex);\n                break;\n            // Close\n            case 'Esc':\n                this.close();\n                break;\n        }\n    }\n    select(index) {\n        const result = this.results[index];\n        if (!result) {\n            Logger.warn(`No autocomplete result found at index: ${index}`);\n            return;\n        }\n        let inputValue;\n        if (result.formattedAddress.includes(result.addressLabel)) {\n            inputValue = result.formattedAddress;\n        }\n        else {\n            const label = result.placeLabel || result.addressLabel;\n            inputValue = `${label}, ${result.formattedAddress}`;\n        }\n        this.inputField.value = inputValue;\n        const onSelection = this.config.onSelection;\n        if (onSelection) {\n            onSelection(result);\n        }\n        // clear results list\n        this.close();\n    }\n    clearResultsList() {\n        this.resultsList.innerHTML = '';\n        this.results = [];\n    }\n    // remove elements from DOM\n    remove() {\n        Logger.debug('AutocompleteUI removed.');\n        this.inputField.remove();\n        this.resultsList.remove();\n        this.wrapper.remove();\n    }\n    setNear(near) {\n        if (near === undefined || near === null) {\n            this.near = undefined;\n        }\n        else if (typeof near === 'string') {\n            this.near = near;\n        }\n        else {\n            this.near = `${near.latitude},${near.longitude}`;\n        }\n        return this;\n    }\n    setPlaceholder(placeholder) {\n        this.config.placeholder = placeholder;\n        this.inputField.placeholder = placeholder;\n        return this;\n    }\n    setDisabled(disabled) {\n        this.config.disabled = disabled;\n        this.inputField.disabled = disabled;\n        return this;\n    }\n    setResponsive(responsive) {\n        this.config.responsive = responsive;\n        setWidth(this.wrapper, this.config);\n        return this;\n    }\n    setWidth(width) {\n        this.config.width = width;\n        setWidth(this.wrapper, this.config);\n        return this;\n    }\n    setMaxHeight(height) {\n        this.config.maxHeight = height;\n        setHeight(this.resultsList, this.config);\n        return this;\n    }\n    setMinCharacters(minCharacters) {\n        this.config.minCharacters = minCharacters;\n        this.config.threshold = minCharacters;\n        return this;\n    }\n    setLimit(limit) {\n        this.config.limit = limit;\n        return this;\n    }\n    setShowMarkers(showMarkers) {\n        this.config.showMarkers = showMarkers;\n        if (showMarkers) {\n            const marker = document.createElement('img');\n            marker.classList.add(CLASSNAMES.RESULTS_MARKER);\n            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));\n            const resultItems = this.resultsList.getElementsByTagName('li');\n            for (let i = 0; i < resultItems.length; i++) {\n                const currentMarker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];\n                if (!currentMarker) {\n                    resultItems[i].prepend(marker.cloneNode());\n                }\n            }\n        }\n        else {\n            const resultItems = this.resultsList.getElementsByTagName('li');\n            for (let i = 0; i < resultItems.length; i++) {\n                const marker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];\n                if (marker) {\n                    marker.remove();\n                }\n            }\n        }\n        return this;\n    }\n    setMarkerColor(color) {\n        this.config.markerColor = color;\n        const marker = this.resultsList.getElementsByClassName(CLASSNAMES.RESULTS_MARKER);\n        for (let i = 0; i < marker.length; i++) {\n            marker[i].setAttribute('src', getMarkerIcon(color));\n        }\n        return this;\n    }\n    setHideResultsOnBlur(hideResultsOnBlur) {\n        this.config.hideResultsOnBlur = hideResultsOnBlur;\n        if (hideResultsOnBlur) {\n            this.inputField.addEventListener('blur', this.close.bind(this), true);\n        }\n        else {\n            this.inputField.removeEventListener('blur', this.close.bind(this), true);\n        }\n        return this;\n    }\n}\n\nclass Radar extends Radar$1 {\n    // \"ui\" namespace for Maps and Autocomplete\n    static get ui() {\n        return {\n            maplibregl: MapUI.getMapLibre(),\n            map: MapUI.createMap,\n            marker: MapUI.createMarker,\n            popup: MapUI.createPopup,\n            autocomplete: AutocompleteUI.createAutocomplete,\n        };\n    }\n}\n\n\n//# sourceMappingURL=radar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmFkYXItc2RrLWpzL2Rpc3QvcmFkYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFdBQVc7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxV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QUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNLElBQUksd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsR0FBRyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3JhZGFyLXNkay1qcy9kaXN0L3JhZGFyLmpzPzNjNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1hcGxpYnJlZ2wgZnJvbSAnbWFwbGlicmUtZ2wnO1xuXG5jbGFzcyBDb25maWcge1xuICAgIHN0YXRpYyBzZXR1cChvcHRpb25zID0ge30pIHtcbiAgICAgICAgQ29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KCkge1xuICAgICAgICByZXR1cm4gQ29uZmlnLm9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhcigpIHtcbiAgICAgICAgQ29uZmlnLm9wdGlvbnMgPSB7fTtcbiAgICB9XG59XG5Db25maWcuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbGl2ZTogZmFsc2UsXG4gICAgbG9nTGV2ZWw6ICdlcnJvcicsXG4gICAgaG9zdDogJ2h0dHBzOi8vYXBpLnJhZGFyLmlvJyxcbiAgICB2ZXJzaW9uOiAndjEnLFxuICAgIGRlYnVnOiBmYWxzZSxcbn07XG5cbmNvbnN0IExPR19MRVZFTFMgPSB7XG4gICAgbm9uZTogMCxcbiAgICBlcnJvcjogMSxcbiAgICB3YXJuOiAyLFxuICAgIGluZm86IDMsXG4gICAgZGVidWc6IDQsXG59O1xuLy8gZ2V0IHRoZSBudW1lcmljIGxldmVsIGZvciBsb2dMZXZlbCBvcHRpb25cbmNvbnN0IGdldExldmVsID0gKCkgPT4ge1xuICAgIC8vIGRpc2FibGUgbG9nZ2luZyBpbiB0ZXN0c1xuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LlJBREFSX1RFU1RfRU5WKSB7XG4gICAgICAgIHJldHVybiBMT0dfTEVWRUxTLm5vbmU7XG4gICAgfVxuICAgIGNvbnN0IHsgbG9nTGV2ZWwsIGRlYnVnIH0gPSBDb25maWcuZ2V0KCk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHJldHVybiBMT0dfTEVWRUxTLmRlYnVnO1xuICAgIH1cbiAgICBpZiAobG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIExPR19MRVZFTFNbbG9nTGV2ZWxdO1xuICAgIH1cbiAgICByZXR1cm4gTE9HX0xFVkVMUy5lcnJvcjsgLy8gZGVmYXVsdCB0byBlcnJvci1sZXZlbCBsb2dnaW5nIGlmIG5vdCBzZXRcbn07XG5jbGFzcyBMb2dnZXIge1xuICAgIHN0YXRpYyBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnZXRMZXZlbCgpID09PSBMT0dfTEVWRUxTLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmFkYXIgU0RLIChkZWJ1Zyk6ICR7bWVzc2FnZS50cmltKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGluZm8obWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2V0TGV2ZWwoKSA+PSBMT0dfTEVWRUxTLmluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSYWRhciBTREs6ICR7bWVzc2FnZS50cmltKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHdhcm4obWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2V0TGV2ZWwoKSA+PSBMT0dfTEVWRUxTLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmFkYXIgU0RLOiAke21lc3NhZ2UudHJpbSgpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnZXRMZXZlbCgpID49IExPR19MRVZFTFMuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJhZGFyIFNESzogJHttZXNzYWdlLnRyaW0oKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU3RvcmFnZSB7XG4gICAgLy8gbG9jYWwgc3RvcmFnZSBrZXkgZGVmaW5pdGlvbnMgZm9yIGlkZW50aWZ5aW5nIHRyYWNrIHVzZXJzXG4gICAgc3RhdGljIGdldCBVU0VSX0lEKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLXVzZXJJZCc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgREVWSUNFX0lEKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLWRldmljZUlkJztcbiAgICB9XG4gICAgc3RhdGljIGdldCBJTlNUQUxMX0lEKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLWluc3RhbGxJZCc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgU0VTU0lPTl9JRCgpIHtcbiAgICAgICAgcmV0dXJuICdyYWRhci1zZXNzaW9uSWQnO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERFU0NSSVBUSU9OKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLWRlc2NyaXB0aW9uJztcbiAgICB9XG4gICAgc3RhdGljIGdldCBNRVRBREFUQSgpIHtcbiAgICAgICAgcmV0dXJuICdyYWRhci1tZXRhZGF0YSc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgQ0FDSEVEX0xPQ0FUSU9OKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLWNhY2hlZC1sb2NhdGlvbic7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgVFJJUF9PUFRJT05TKCkge1xuICAgICAgICByZXR1cm4gJ3JhZGFyLXRyaXAtb3B0aW9ucyc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTdG9yYWdlKCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICBMb2dnZXIud2FybignbG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuZ2V0U3RvcmFnZSgpO1xuICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldFN0b3JhZ2UoKTtcbiAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SlNPTihrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBMb2dnZXIud2FybihgY291bGQgbm90IGdldEpTT04gZnJvbSBzdG9yYWdlIGZvciBrZXk6ICR7a2V5fWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldFN0b3JhZ2UoKTtcbiAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGNsZWFyKCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5nZXRTdG9yYWdlKCk7XG4gICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5jbGVhcigpO1xuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5jbGFzcyBSYWRhckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7IC8vIHRvIGJlIG92ZXJyaWRkZW4gKHN1cHBvcnQgZm9yIGxlZ2FjeSBzdGF0dXMpXG4gICAgfVxufVxuY2xhc3MgUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yIGV4dGVuZHMgUmFkYXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyUHVibGlzaGFibGVLZXlFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ0VSUk9SX1BVQkxJU0hBQkxFX0tFWSc7XG4gICAgfVxufVxuY2xhc3MgUmFkYXJMb2NhdGlvbkVycm9yIGV4dGVuZHMgUmFkYXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyTG9jYXRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ0VSUk9SX0xPQ0FUSU9OJztcbiAgICB9XG59XG5jbGFzcyBSYWRhclBlcm1pc3Npb25zRXJyb3IgZXh0ZW5kcyBSYWRhckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmFkYXJQZXJtaXNzaW9uc0Vycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfUEVSTUlTU0lPTlMnO1xuICAgIH1cbn1cbmNsYXNzIFJhZGFyVmVyaWZ5QXBwRXJyb3IgZXh0ZW5kcyBSYWRhckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1JhZGFyIFZlcmlmeSBhcHAgbm90IHJ1bm5pbmcuJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSYWRhclZlcmlmeUFwcEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfVkVSSUZZX0FQUCc7XG4gICAgfVxufVxuLy8gSFRUUCBFcnJvcnNcbmNsYXNzIFJhZGFyQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgUmFkYXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnQmFkIHJlcXVlc3QuJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSYWRhckJhZFJlcXVlc3RFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IDQwMDtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdFUlJPUl9CQURfUkVRVUVTVCc7XG4gICAgfVxufVxuY2xhc3MgUmFkYXJVbmF1dGhvcml6ZWRFcnJvciBleHRlbmRzIFJhZGFyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1VuYXV0aG9yaXplZC4nKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyVW5hdXRob3JpemVkRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSA0MDE7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfVU5BVVRIT1JJWkVEJztcbiAgICB9XG59XG5jbGFzcyBSYWRhclBheW1lbnRSZXF1aXJlZEVycm9yIGV4dGVuZHMgUmFkYXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnUGF5bWVudCByZXF1aXJlZC4nKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyUGF5bWVudFJlcXVpcmVkRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSA0MDI7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfUEFZTUVOVF9SRVFVSVJFRCc7XG4gICAgfVxufVxuY2xhc3MgUmFkYXJGb3JiaWRkZW5FcnJvciBleHRlbmRzIFJhZGFyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ0ZvcmJpZGRlbi4nKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyRm9yYmlkZGVuRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSA0MDM7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfRk9SQklEREVOJztcbiAgICB9XG59XG5jbGFzcyBSYWRhck5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBSYWRhckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubWV0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICdOb3QgZm91bmQuJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSYWRhck5vdEZvdW5kRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSA0MDQ7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfTk9UX0ZPVU5EJztcbiAgICB9XG59XG5jbGFzcyBSYWRhclJhdGVMaW1pdEVycm9yIGV4dGVuZHMgUmFkYXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1JhdGUgbGltaXQgZXhjZWVkZWQuJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSYWRhclJhdGVMaW1pdEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gNDI5O1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnRVJST1JfUkFURV9MSU1JVCc7XG4gICAgfVxufVxuY2xhc3MgUmFkYXJTZXJ2ZXJFcnJvciBleHRlbmRzIFJhZGFyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ0ludGVybmFsIHNlcnZlciBlcnJvci4nKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JhZGFyU2VydmVyRXJyb3InO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ0VSUk9SX1NFUlZFUic7XG4gICAgfVxufVxuY2xhc3MgUmFkYXJOZXR3b3JrRXJyb3IgZXh0ZW5kcyBSYWRhckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1JlcXVlc3QgdGltZWQgb3V0LicpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmFkYXJOZXR3b3JrRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdFUlJPUl9ORVRXT1JLJztcbiAgICB9XG59XG5jbGFzcyBSYWRhclVua25vd25FcnJvciBleHRlbmRzIFJhZGFyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1NvbWV0aGluZyB3ZW50IHdyb25nLicpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmFkYXJVbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ0VSUk9SX1VOS05PV04nO1xuICAgIH1cbn1cbmNsYXNzIFJhZGFyQXV0b2NvbXBsZXRlQ29udGFpbmVyTm90Rm91bmQgZXh0ZW5kcyBSYWRhckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmFkYXJBdXRvY29tcGxldGVDb250YWluZXJOb3RGb3VuZCc7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ0NPTlRBSU5FUl9OT1RfRk9VTkQnO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9QT1NJVElPTl9PUFRJT05TID0ge1xuICAgIG1heGltdW1BZ2U6IDAsXG4gICAgdGltZW91dDogMTAwMCAqIDMwLFxuICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcbn07XG4vLyBzZXQgXCJlbmFibGVIaWdoQWNjdXJhY3lcIiBmb3IgbmF2aWdhdG9yIG9ubHkgd2hlbiBkZXNpcmVkQWNjdXJhY3kgaXMgXCJoaWdoXCJcbmNvbnN0IHVzZUhpZ2hBY2N1cmFjeSA9IChkZXNpcmVkQWNjdXJhY3kpID0+IChCb29sZWFuKGRlc2lyZWRBY2N1cmFjeSA9PT0gJ2hpZ2gnKSk7XG5jbGFzcyBOYXZpZ2F0b3Ige1xuICAgIHN0YXRpYyBnZXRDdXJyZW50UG9zaXRpb24ob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hdmlnYXRvciB8fCAhbmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFJhZGFyTG9jYXRpb25FcnJvcignbmF2aWdhdG9yLmdlb2xvY2F0aW9uIGlzIG5vdCBhdmFpbGFibGUuJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1c2UgY2FjaGVkIGxvY2F0aW9uIGlmIGF2YWlsYWJsZSBhbmQgb3B0aW9ucyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGVMb2NhdGlvbk1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0NhY2hlZExvY2F0aW9uID0gU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuQ0FDSEVEX0xPQ0FUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdDYWNoZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZExvY2F0aW9uID0gSlNPTi5wYXJzZShyYXdDYWNoZWRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSwgZXhwaXJlc0F0IH0gPSBjYWNoZWRMb2NhdGlvbiB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA8IHBhcnNlSW50KGV4cGlyZXNBdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhdGl0dWRlICYmIGxvbmdpdHVkZSAmJiBhY2N1cmFjeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCBsb2FkIGNhY2hlZCBsb2NhdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXQgb3B0aW9ucyBmcm9tIGNvbmZpZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUE9TSVRJT05fT1BUSU9OUyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25NYXhpbXVtQWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zLm1heGltdW1BZ2UgPSBvcHRpb25zLmxvY2F0aW9uTWF4aW11bUFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25UaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLmxvY2F0aW9uVGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVzaXJlZEFjY3VyYWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zLmVuYWJsZUhpZ2hBY2N1cmFjeSA9IHVzZUhpZ2hBY2N1cmFjeShvcHRpb25zLmRlc2lyZWRBY2N1cmFjeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBvcHRpb25zIGZyb20gb3ZlcnJpZGVzXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5kZXNpcmVkQWNjdXJhY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk9wdGlvbnMuZW5hYmxlSGlnaEFjY3VyYWN5ID0gdXNlSGlnaEFjY3VyYWN5KG92ZXJyaWRlcy5kZXNpcmVkQWNjdXJhY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbyhgVXNpbmcgZ2VvbG9jYXRpb24gb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShwb3NpdGlvbk9wdGlvbnMpfWApO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uIGZyb20gYnJvd3NlclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb24gfHwgIXBvc2l0aW9uLmNvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJMb2NhdGlvbkVycm9yKCdkZXZpY2UgbG9jYXRpb24gcmV0dXJuIGVtcHR5IGNvb3JkaW5hdGVzLicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGFjY3VyYWN5IH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGxvY2F0aW9uIGlmIG9wdGlvbiBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGVMb2NhdGlvbk1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlTG9jYXRpb25NaW51dGVzID0gTnVtYmVyLnBhcnNlRmxvYXQob3B0aW9ucy5jYWNoZUxvY2F0aW9uTWludXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gdXBkYXRlZEF0ICsgKGNhY2hlTG9jYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTsgLy8gY29udmVydCB0byBtc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdExvY2F0aW9uID0geyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSwgdXBkYXRlZEF0LCBleHBpcmVzQXQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLkNBQ0hFRF9MT0NBVElPTiwgSlNPTi5zdHJpbmdpZnkobGFzdExvY2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSB9KTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HZW9sb2NhdGlvblBvc2l0aW9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgMSBtZWFucyBsb2NhdGlvbiBwZXJtaXNzaW9ucyBkZW5pZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGVzIDIgYW5kIDMgbWVhbiBsb2NhdGlvbiB1bmF2YWlsYWJsZSBvciB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhclBlcm1pc3Npb25zRXJyb3IoJ0xvY2F0aW9uIHBlcm1pc3Npb25zIGRlbmllZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJMb2NhdGlvbkVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGxvY2F0aW9uLicpKTtcbiAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGVybWlzc2lvblN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IgfHwgIW5hdmlnYXRvci5wZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhckxvY2F0aW9uRXJyb3IoJ25hdmlnYXRvci5wZXJtaXNzaW9ucyBpcyBub3QgYXZhaWxhYmxlLicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ2dlb2xvY2F0aW9uJyB9KS50aGVuKChwZXJtaXNzaW9uc1N0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYXRpb25BdXRob3JpemF0aW9uID0gJ05PVF9ERVRFUk1JTkVEJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwZXJtaXNzaW9uc1N0YXR1cy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ3JhbnRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25BdXRob3JpemF0aW9uID0gJ0dSQU5URURfRk9SRUdST1VORCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZW5pZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbiA9ICdERU5JRUQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvbXB0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkF1dGhvcml6YXRpb24gPSAnTk9UX0RFVEVSTUlORUQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxvY2F0aW9uQXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG52YXIgU0RLX1ZFUlNJT04gPSAnNC40LjMnO1xuXG5jb25zdCBpbkZsaWdodFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuY2xhc3MgSHR0cCB7XG4gICAgc3RhdGljIHJlcXVlc3QoeyBtZXRob2QsIHBhdGgsIGRhdGEsIGhvc3QsIHZlcnNpb24sIGhlYWRlcnMgPSB7fSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0SWQsIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgcHVibGlzaGFibGVLZXkgb24gcmVxdWVzdFxuICAgICAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hhYmxlS2V5ID0gb3B0aW9ucy5wdWJsaXNoYWJsZUtleTtcbiAgICAgICAgICAgICAgICBpZiAoIXB1Ymxpc2hhYmxlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yKCdwdWJsaXNoYWJsZUtleSBub3Qgc2V0LicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCByZXF1ZXN0IFVSTFxuICAgICAgICAgICAgICAgIGNvbnN0IHVybEhvc3QgPSBob3N0IHx8IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxWZXJzaW9uID0gdmVyc2lvbiB8fCBvcHRpb25zLnZlcnNpb247XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGAke3VybEhvc3R9LyR7dXJsVmVyc2lvbn0vJHtwYXRofWA7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSByZXF1ZXN0IGRhdGFcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEgfHwge30pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBkYXRhIHRvIHF1ZXJ5c3RyaW5nIGZvciBHRVQgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhib2R5KS5tYXAoKGtleSkgPT4gKGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQoYm9keVtrZXldKX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBwYXJhbXMuam9pbignJicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gYCR7dXJsfT8ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHVuZGVmaW5lZDsgLy8gZG9udCBzZW5kIGJvZHkgZm9yIEdFVCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbi1mbGlnaHQgcmVxdWVzdHMgd2l0aCBtYXRjaGluZyByZXF1ZXN0SWRzXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5GbGlnaHRSZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTsgLy8gYWJvcnQgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIHJlZmVyZW5jZSB0byByZXF1ZXN0XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpbkZsaWdodFJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHB1Ymxpc2hhYmxlS2V5LFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnWC1SYWRhci1EZXZpY2UtVHlwZSc6ICdXZWInLFxuICAgICAgICAgICAgICAgICAgICAnWC1SYWRhci1TREstVmVyc2lvbic6IFNES19WRVJTSU9OLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1c3RvbSBjb25maWcgaGVhZGVycyBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ0hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ2V0UmVxdWVzdEhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnSGVhZGVycyA9IG9wdGlvbnMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29tYmluZXMgZGVmYXVsdCBoZWFkZXJzIHdpdGggY3VzdG9tIGhlYWRlcnMgYW5kIGNvbmZpZyBoZWFkZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdEhlYWRlcnMsIGNvbmZpZ0hlYWRlcnMsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIHNldCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWxsSGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYWxsSGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkKSB7IC8vIGNsZWFyIGluLWZsaWdodCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkZsaWdodFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7IGNvZGU6IHhoci5zdGF0dXMsIGRhdGE6IHhoci5yZXNwb25zZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFJhZGFyU2VydmVyRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PT0gJ0VSUk9SX1BFUk1JU1NJT05TJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJQZXJtaXNzaW9uc0Vycm9yKCdMb2NhdGlvbiBwZXJtaXNzaW9ucyBub3QgZ3JhbnRlZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09ICdFUlJPUl9MT0NBVElPTicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFJhZGFyTG9jYXRpb25FcnJvcignQ291bGQgbm90IGRldGVybWluZSBsb2NhdGlvbi4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09ICdFUlJPUl9ORVRXT1JLJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJOZXR3b3JrRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5kZWJ1ZyhgQVBJIGNhbGwgZmFpbGVkOiAke3VybH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJCYWRSZXF1ZXN0RXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4aHIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJVbmF1dGhvcml6ZWRFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhoci5zdGF0dXMgPT09IDQwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhclBheW1lbnRSZXF1aXJlZEVycm9yKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyRm9yYmlkZGVuRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4aHIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJOb3RGb3VuZEVycm9yKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyUmF0ZUxpbWl0RXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICg1MDAgPD0geGhyLnN0YXR1cyAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyU2VydmVyRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJVbmtub3duRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob3N0ICYmIChob3N0ID09PSAnaHR0cDovL2xvY2FsaG9zdDo1MjUxNicgfHwgaG9zdCA9PT0gJ2h0dHBzOi8vcmFkYXItdmVyaWZ5LmNvbTo1MjUxNicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyVmVyaWZ5QXBwRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyU2VydmVyRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJWZXJpZnlBcHBFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KGJvZHkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIEFkZHJlc3Nlc0FQSSB7XG4gICAgc3RhdGljIHZhbGlkYXRlQWRkcmVzcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAnYWRkcmVzc2VzL3ZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgcmVzdWx0IH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlQWRkcmVzc1JlcyA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQWRkcmVzc1Jlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQWRkcmVzc1JlcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBnZW5lcmF0ZVVVSUQgPSAoKSA9PiB7XG4gICAgY29uc3QgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGNoYXIpID0+IHtcbiAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIGNvbnN0IHYgPSAoY2hhciA9PSAneCcpID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiB1dWlkO1xufTtcbmNsYXNzIERldmljZSB7XG4gICAgc3RhdGljIGdldERldmljZUlkKCkge1xuICAgICAgICAvLyB1c2UgZXhpc3RpbmcgZGV2aWNlSWQgaWYgcHJlc2VudFxuICAgICAgICBjb25zdCBkZXZpY2VJZCA9IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLkRFVklDRV9JRCk7XG4gICAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIG5ldyBkZXZpY2VJZFxuICAgICAgICBjb25zdCB1dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLkRFVklDRV9JRCwgdXVpZCk7XG4gICAgICAgIHJldHVybiB1dWlkO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5zdGFsbElkKCkge1xuICAgICAgICAvLyB1c2UgZXhpc3RpbmcgaW5zdGFsbElkIGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5JTlNUQUxMX0lEKTtcbiAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2VuZXJhdGUgbmV3IGluc3RhbGxJZFxuICAgICAgICBjb25zdCB1dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLklOU1RBTExfSUQsIHV1aWQpO1xuICAgICAgICByZXR1cm4gdXVpZDtcbiAgICB9XG59XG5cbmNvbnN0IFNFU1NJT05fVElNRU9VVF9TRUNTID0gMzAwOyAvLyA1IG1pbnNcbmNvbnN0IGlzVmFsaWQgPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC50cnVuYyhEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IE51bWJlci5wYXJzZUludChzZXNzaW9uSWQpO1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhub3cgLSBzZXNzaW9uKTtcbiAgICByZXR1cm4gZGlmZiA8IFNFU1NJT05fVElNRU9VVF9TRUNTO1xufTtcbmNsYXNzIFNlc3Npb24ge1xuICAgIHN0YXRpYyBnZXRTZXNzaW9uSWQoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlNFU1NJT05fSUQpO1xuICAgICAgICAvLyByZXVzZSBzZXNzaW9uIGlmIHN0aWxsIHdpdGhpbiA1IG1pbiB0aHJlc2hvbGRcbiAgICAgICAgaWYgKHNlc3Npb25JZCAmJiBpc1ZhbGlkKHNlc3Npb25JZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBzZXNzaW9uIGlmIGRvZXMgbm90IGFscmVhZHkgZXhpc3Qgb3IgZXhwaXJlZFxuICAgICAgICBjb25zdCBuZXdTZXNzaW9uSWQgPSBNYXRoLnRydW5jKERhdGUubm93KCkgLyAxMDAwKS50b1N0cmluZygpOyAvLyB1bml4IHRzIGluIHNlY29uZHNcbiAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuU0VTU0lPTl9JRCwgbmV3U2Vzc2lvbklkKTtcbiAgICAgICAgcmV0dXJuIG5ld1Nlc3Npb25JZDtcbiAgICB9XG59XG5cbmNsYXNzIENvbmZpZ0FQSSB7XG4gICAgc3RhdGljIGdldENvbmZpZyhwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gIT0gJ3YxJykge1xuICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTa2lwcGluZyAvY29uZmlnIGNhbGwuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBwYXJhbXMuZGV2aWNlSWQgfHwgRGV2aWNlLmdldERldmljZUlkKCk7XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsSWQgPSBwYXJhbXMuaW5zdGFsbElkIHx8IERldmljZS5nZXRJbnN0YWxsSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IFNlc3Npb24uZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbkF1dGhvcml6YXRpb24gPSB5aWVsZCBOYXZpZ2F0b3IuZ2V0UGVybWlzc2lvblN0YXR1cygpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgICAgICBpbnN0YWxsSWQsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdjb25maWcnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKGBFcnJvciBjYWxsaW5nIC9jb25maWc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGV4dEFQSSB7XG4gICAgc3RhdGljIGdldENvbnRleHQobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAvLyBnZXQgZGV2aWNlIGxvY2F0aW9uIGlmIGNvb3JkaW5hdGVzIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbi5sYXRpdHVkZSB8fCAhbG9jYXRpb24ubG9uZ2l0dWRlKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSB5aWVsZCBOYXZpZ2F0b3IuZ2V0Q3VycmVudFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGFjY3VyYWN5IH0gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICdjb250ZXh0JyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBgJHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9YCxcbiAgICAgICAgICAgICAgICAgICAgYWNjdXJhY3ksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBnZW9mZW5jZXMsIHBsYWNlLCBjb3VudHJ5LCBzdGF0ZSwgZG1hLCBwb3N0YWxDb2RlLCB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0UmVzID0ge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGdlb2ZlbmNlcyxcbiAgICAgICAgICAgICAgICBwbGFjZSxcbiAgICAgICAgICAgICAgICBjb3VudHJ5LFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIGRtYSxcbiAgICAgICAgICAgICAgICBwb3N0YWxDb2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udmVyc2lvbnNBUEkge1xuICAgIHN0YXRpYyBsb2dDb252ZXJzaW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQgfHwgU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuVVNFUl9JRCk7XG4gICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IHBhcmFtcy5kZXZpY2VJZCB8fCBEZXZpY2UuZ2V0RGV2aWNlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbGxJZCA9IHBhcmFtcy5pbnN0YWxsSWQgfHwgRGV2aWNlLmdldEluc3RhbGxJZCgpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgfHwge307XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBwYXJhbXMuY3JlYXRlZEF0O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5yZXZlbnVlKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEucmV2ZW51ZSA9IHBhcmFtcy5yZXZlbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgICAgICBpbnN0YWxsSWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVkQXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVhdGVkQXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jcmVhdGVkQXQgPSBjcmVhdGVkQXQudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuY3JlYXRlZEF0ID0gKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJ2V2ZW50cycsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2lvblJlcyA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogcmVzcG9uc2UuZXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJzaW9uUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVyc2lvblJlcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBHZW9jb2Rpbmcge1xuICAgIHN0YXRpYyBmb3J3YXJkR2VvY29kZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IHF1ZXJ5LCBsYXllcnMsIGNvdW50cnkgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICdnZW9jb2RlL2ZvcndhcmQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGxheWVycyxcbiAgICAgICAgICAgICAgICAgICAgY291bnRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmb3J3YXJkR2VvY29kZVJlcyA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IHJlc3BvbnNlLmFkZHJlc3NlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGZvcndhcmRHZW9jb2RlUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9yd2FyZEdlb2NvZGVSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgcmV2ZXJzZUdlb2NvZGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgbGV0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgbGF5ZXJzIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoIWxhdGl0dWRlIHx8ICFsb25naXR1ZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHlpZWxkIE5hdmlnYXRvci5nZXRDdXJyZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZSA9IGxvY2F0aW9uLmxhdGl0dWRlO1xuICAgICAgICAgICAgICAgIGxvbmdpdHVkZSA9IGxvY2F0aW9uLmxvbmdpdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICdnZW9jb2RlL3JldmVyc2UnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGAke2xhdGl0dWRlfSwke2xvbmdpdHVkZX1gLFxuICAgICAgICAgICAgICAgICAgICBsYXllcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZUdlb2NvZGVSZXMgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzOiByZXNwb25zZS5hZGRyZXNzZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZVJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldmVyc2VHZW9jb2RlUmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGlwR2VvY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAnZ2VvY29kZS9pcCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGlwR2VvY29kZVJlcyA9IHtcbiAgICAgICAgICAgICAgICBpcDogcmVzcG9uc2UuaXAsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogcmVzcG9uc2UuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBwcm94eTogcmVzcG9uc2UucHJveHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBpcEdlb2NvZGVSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpcEdlb2NvZGVSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUm91dGluZ0FQSSB7XG4gICAgc3RhdGljIGRpc3RhbmNlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGxldCB7IG9yaWdpbiwgZGVzdGluYXRpb24sIG1vZGVzLCB1bml0cywgZ2VvbWV0cnksIGdlb21ldHJ5UG9pbnRzLCBhdm9pZCwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIC8vIHVzZSBicm93c2VyIGxvY2F0aW9uIGlmIFwibmVhclwiIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IHlpZWxkIE5hdmlnYXRvci5nZXRDdXJyZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBgJHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7IC8vIG9yaWdpbiBpcyBcIkxvY2F0aW9uXCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgb3JpZ2luID0gYCR7bGF0aXR1ZGV9LCR7bG9uZ2l0dWRlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBgJHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1vZGVzKSkge1xuICAgICAgICAgICAgICAgIG1vZGVzID0gbW9kZXMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXZvaWQpKSB7XG4gICAgICAgICAgICAgICAgYXZvaWQgPSBhdm9pZC5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAncm91dGUvZGlzdGFuY2UnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbW9kZXMsXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlQb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIGF2b2lkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlUmVzID0ge1xuICAgICAgICAgICAgICAgIHJvdXRlczogcmVzcG9uc2Uucm91dGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZVJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBtYXRyaXgocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgbGV0IHsgb3JpZ2lucywgZGVzdGluYXRpb25zLCBtb2RlLCB1bml0cywgYXZvaWQsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICAvLyB1c2UgYnJvd3NlciBsb2NhdGlvbiBpZiBcIm5lYXJcIiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghb3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0geWllbGQgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5TdHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luU3RyaW5ncy5wdXNoKGAke2xhdGl0dWRlfSwke2xvbmdpdHVkZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JpZ2lucyA9IG9yaWdpblN0cmluZ3Muam9pbignfCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW5zKSkgeyAvLyBvcmlnaW4gaXMgYSBsaXN0IG9mIFwiTG9jYXRpb25cIiBvYmplY3RzXG4gICAgICAgICAgICAgICAgb3JpZ2lucyA9IG9yaWdpbnMubWFwKChsb2NhdGlvbikgPT4gYCR7bG9jYXRpb24ubGF0aXR1ZGV9LCR7bG9jYXRpb24ubG9uZ2l0dWRlfWApLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYXJyYXkgdG8gcGlwZS1kZWxpbWl0ZWQgc3RyaW5nXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25zID0gZGVzdGluYXRpb25zLm1hcCgobG9jYXRpb24pID0+IGAke2xvY2F0aW9uLmxhdGl0dWRlfSwke2xvY2F0aW9uLmxvbmdpdHVkZX1gKS5qb2luKCd8Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdm9pZCkpIHtcbiAgICAgICAgICAgICAgICBhdm9pZCA9IGF2b2lkLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICdyb3V0ZS9tYXRyaXgnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2lucyxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICB1bml0cyxcbiAgICAgICAgICAgICAgICAgICAgYXZvaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4UmVzID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbnM6IHJlc3BvbnNlLm9yaWdpbnMsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25zOiByZXNwb25zZS5kZXN0aW5hdGlvbnMsXG4gICAgICAgICAgICAgICAgbWF0cml4OiByZXNwb25zZS5tYXRyaXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXhSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU2VhcmNoQVBJIHtcbiAgICBzdGF0aWMgYXV0b2NvbXBsZXRlKHBhcmFtcywgcmVxdWVzdElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgbGV0IHsgcXVlcnksIG5lYXIsIGxpbWl0LCBsYXllcnMsIGNvdW50cnlDb2RlLCBleHBhbmRVbml0cywgbWFpbGFibGUsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICAvLyBuZWFyIGNhbiBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyBvciBMb2NhdGlvbiBvYmplY3RcbiAgICAgICAgICAgIC8vIGlmIFwibmVhclwiIGlzIG5vdCBwcm92aWRlZCwgcmVxdWVzdCB3aWxsIGZhbGxiYWNrIHRvIElQIGJhc2VkIGxvY2F0aW9uXG4gICAgICAgICAgICBpZiAobmVhciAmJiB0eXBlb2YgbmVhciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVhci5sYXRpdHVkZSAmJiBuZWFyLmxvbmdpdHVkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyID0gYCR7bmVhci5sYXRpdHVkZX0sJHtuZWFyLmxvbmdpdHVkZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICdzZWFyY2gvYXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBuZWFyLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgICAgICAgICAgICBjb3VudHJ5Q29kZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kVW5pdHMsXG4gICAgICAgICAgICAgICAgICAgIG1haWxhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhdXRvY29tcGxldGVSZXMgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzOiByZXNwb25zZS5hZGRyZXNzZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoR2VvZmVuY2VzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGxldCB7IG5lYXIsIHJhZGl1cywgdGFncywgbWV0YWRhdGEsIGxpbWl0LCBpbmNsdWRlR2VvbWV0cnksIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICAvLyB1c2UgYnJvd3NlciBsb2NhdGlvbiBpZiBcIm5lYXJcIiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghbmVhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0geWllbGQgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG5lYXIgPSBgJHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZWFyICE9PSAnc3RyaW5nJykgeyAvLyBuZWFyIGlzIFwiTG9jYXRpb25cIiBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IG5lYXI7XG4gICAgICAgICAgICAgICAgbmVhciA9IGAke2xhdGl0dWRlfSwke2xvbmdpdHVkZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBhcnJheXMgdG8gY29tbWEtc3RyaW5nc1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gdGFncy5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAnc2VhcmNoL2dlb2ZlbmNlcycsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuZWFyLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUdlb21ldHJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGdlb2ZlbmNlc1NlYXJjaFJlcyA9IHtcbiAgICAgICAgICAgICAgICBnZW9mZW5jZXM6IHJlc3BvbnNlLmdlb2ZlbmNlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGdlb2ZlbmNlc1NlYXJjaFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlb2ZlbmNlc1NlYXJjaFJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZWFyY2hQbGFjZXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgbGV0IHsgbmVhciwgcmFkaXVzLCBjaGFpbnMsIGNhdGVnb3JpZXMsIGdyb3VwcywgbGltaXQsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICAvLyB1c2UgYnJvd3NlciBsb2NhdGlvbiBpZiBcIm5lYXJcIiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghbmVhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0geWllbGQgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG5lYXIgPSBgJHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZWFyICE9PSAnc3RyaW5nJykgeyAvLyBuZWFyIGlzIFwiTG9jYXRpb25cIiBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IG5lYXI7XG4gICAgICAgICAgICAgICAgbmVhciA9IGAke2xhdGl0dWRlfSwke2xvbmdpdHVkZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBhcnJheXMgdG8gY29tbWEtc3RyaW5nc1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhaW5zKSkge1xuICAgICAgICAgICAgICAgIGNoYWlucyA9IGNoYWlucy5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwcykpIHtcbiAgICAgICAgICAgICAgICBncm91cHMgPSBncm91cHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJ3NlYXJjaC9wbGFjZXMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmVhcixcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbnMsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGxhY2VTZWFyY2hSZXMgPSB7XG4gICAgICAgICAgICAgICAgcGxhY2VzOiByZXNwb25zZS5wbGFjZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBwbGFjZVNlYXJjaFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlU2VhcmNoUmVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDE5ODY0MVxuY29uc3QgaXNWYWxpZERhdGUgPSAoZGF0ZSkgPT4gZGF0ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0ZSkgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAhaXNOYU4oZGF0ZSk7XG5jbGFzcyBUcmlwc0FQSSB7XG4gICAgc3RhdGljIHNldFRyaXBPcHRpb25zKHRyaXBPcHRpb25zKSB7XG4gICAgICAgIGlmICghdHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIFRyaXBzQVBJLmNsZWFyVHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmlwT3B0aW9uc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KHRyaXBPcHRpb25zKTtcbiAgICAgICAgTG9nZ2VyLmRlYnVnKGBTYXZpbmcgdHJpcCBvcHRpb25zOiAke3RyaXBPcHRpb25zU3RyaW5nfWApO1xuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5UUklQX09QVElPTlMsIHRyaXBPcHRpb25zU3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFRyaXBPcHRpb25zKCkge1xuICAgICAgICBsZXQgdHJpcE9wdGlvbnMgPSBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5UUklQX09QVElPTlMpO1xuICAgICAgICBpZiAodHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyaXBPcHRpb25zID0gSlNPTi5wYXJzZSh0cmlwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaXBPcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgY2xlYXJUcmlwT3B0aW9ucygpIHtcbiAgICAgICAgU3RvcmFnZS5yZW1vdmVJdGVtKFN0b3JhZ2UuVFJJUF9PUFRJT05TKTtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0VHJpcCh0cmlwT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIHRyaXBPcHRpb25zID0gdHJpcE9wdGlvbnMgfHwgVHJpcHNBUEkuZ2V0VHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghdHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndHJpcE9wdGlvbnMgbm90IHNldCB3aGVuIGNhbGxpbmcgXCJzdGFydFRyaXBcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXNlcklkID0gdHJpcE9wdGlvbnMudXNlcklkIHx8IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpO1xuICAgICAgICAgICAgaWYgKHVzZXJJZCAmJiB1c2VySWQgIT09IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGFzIHVzZXJJZCBmb3IgdHJhY2tpbmcgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5VU0VSX0lELCB1c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBleHRlcm5hbElkLCBkZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLCBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCwgbW9kZSwgbWV0YWRhdGEsIGFwcHJvYWNoaW5nVGhyZXNob2xkLCBzY2hlZHVsZWRBcnJpdmFsQXQsIH0gPSB0cmlwT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsSWQsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25HZW9mZW5jZVRhZyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCxcbiAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGFwcHJvYWNoaW5nVGhyZXNob2xkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZShzY2hlZHVsZWRBcnJpdmFsQXQpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zY2hlZHVsZWRBcnJpdmFsQXQgPSBzY2hlZHVsZWRBcnJpdmFsQXQgPT09IG51bGwgfHwgc2NoZWR1bGVkQXJyaXZhbEF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlZHVsZWRBcnJpdmFsQXQudG9KU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGVkQXJyaXZhbEF0KSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKCdJbnZhbGlkIGRhdGUgZm9ybWF0IGZvciBzY2hlZHVsZWRBcnJpdmFsQXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5zY2hlZHVsZWRBcnJpdmFsQXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJ3RyaXBzJyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzYXZlIHRyaXAgb3B0aW9uc1xuICAgICAgICAgICAgVHJpcHNBUEkuc2V0VHJpcE9wdGlvbnModHJpcE9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdHJpcFJlcyA9IHtcbiAgICAgICAgICAgICAgICB0cmlwOiByZXNwb25zZS50cmlwLFxuICAgICAgICAgICAgICAgIGV2ZW50czogcmVzcG9uc2UuZXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdHJpcFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyaXBSZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlVHJpcCh0cmlwT3B0aW9ucywgc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgdHJpcE9wdGlvbnMgPSB0cmlwT3B0aW9ucyB8fCBUcmlwc0FQSS5nZXRUcmlwT3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKCF0cmlwT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKCd0cmlwT3B0aW9ucyBub3Qgc2V0IHdoZW4gY2FsbGluZyBcInN0YXJ0VHJpcFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGV4dGVybmFsSWQsIGRlc3RpbmF0aW9uR2VvZmVuY2VUYWcsIGRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLCBtb2RlLCBtZXRhZGF0YSwgYXBwcm9hY2hpbmdUaHJlc2hvbGQsIHNjaGVkdWxlZEFycml2YWxBdCwgfSA9IHRyaXBPcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxJZCxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLFxuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYXBwcm9hY2hpbmdUaHJlc2hvbGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREYXRlKHNjaGVkdWxlZEFycml2YWxBdCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNjaGVkdWxlZEFycml2YWxBdCA9IHNjaGVkdWxlZEFycml2YWxBdCA9PT0gbnVsbCB8fCBzY2hlZHVsZWRBcnJpdmFsQXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVkdWxlZEFycml2YWxBdC50b0pTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZWRBcnJpdmFsQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ0ludmFsaWQgZGF0ZSBmb3JtYXQgZm9yIHNjaGVkdWxlZEFycml2YWxBdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnNjaGVkdWxlZEFycml2YWxBdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgcGF0aDogYHRyaXBzLyR7ZXh0ZXJuYWxJZH0vdXBkYXRlYCxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmlwUmVzID0ge1xuICAgICAgICAgICAgICAgIHRyaXA6IHJlc3BvbnNlLnRyaXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiByZXNwb25zZS5ldmVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0cmlwUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJpcFJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wbGV0ZVRyaXAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0cmlwT3B0aW9ucyA9IFRyaXBzQVBJLmdldFRyaXBPcHRpb25zKCk7XG4gICAgICAgICAgICBjb25zdCB0cmlwUmVzcG9uc2UgPSB5aWVsZCBUcmlwc0FQSS51cGRhdGVUcmlwKHRyaXBPcHRpb25zLCAnY29tcGxldGVkJyk7XG4gICAgICAgICAgICAvLyBjbGVhciBsb2NhbCB0cmlwIG9wdGlvbnNcbiAgICAgICAgICAgIFRyaXBzQVBJLmNsZWFyVHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmlwUmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuY2VsVHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaXBPcHRpb25zID0gVHJpcHNBUEkuZ2V0VHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaXBSZXNwb25zZSA9IHlpZWxkIFRyaXBzQVBJLnVwZGF0ZVRyaXAodHJpcE9wdGlvbnMsICdjYW5jZWxlZCcpO1xuICAgICAgICAgICAgLy8gY2xlYXIgbG9jYWwgdHJpcCBvcHRpb25zXG4gICAgICAgICAgICBUcmlwc0FQSS5jbGVhclRyaXBPcHRpb25zKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJpcFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGJhc2U2NEVuY29kZSA9IChzdHIpID0+IGJ0b2Eoc3RyKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG5jb25zdCBzaWduSldUID0gKHBheWxvYWQsIGtleSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWRIZWFkZXIgPSBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBhbGc6ICdIUzI1NicsXG4gICAgICAgIHR5cDogJ0pXVCcsXG4gICAgfSkpO1xuICAgIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICBjb25zdCBrZXlEYXRhID0gZW5jb2Rlci5lbmNvZGUoa2V5KTtcbiAgICBjb25zdCBtZXNzYWdlRGF0YSA9IGVuY29kZXIuZW5jb2RlKGAke2VuY29kZWRIZWFkZXJ9LiR7ZW5jb2RlZFBheWxvYWR9YCk7XG4gICAgY29uc3QgY3J5cHRvS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleURhdGEsIHsgbmFtZTogJ0hNQUMnLCBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9IH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQXJyYXlCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLnNpZ24oJ0hNQUMnLCBjcnlwdG9LZXksIG1lc3NhZ2VEYXRhKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiYXNlNjRFbmNvZGUoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5BcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUFycmF5QnVmZmVyKSkpKTtcbiAgICByZXR1cm4gYCR7ZW5jb2RlZEhlYWRlcn0uJHtlbmNvZGVkUGF5bG9hZH0uJHtzaWduYXR1cmV9YDtcbn0pO1xuXG5jb25zdCBwaW5nID0gKGhvc3QpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldChob3N0KTtcbiAgICAgICAgbGV0IHBpbmdzID0gMDtcbiAgICAgICAgY29uc3QgbGF0ZW5jaWVzID0gW107XG4gICAgICAgIGxldCBwaW5nSW50ZXJ2YWw7XG4gICAgICAgIGxldCB0aW1lb3V0SW50ZXJ2YWw7XG4gICAgICAgIGNvbnN0IHBpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBwaW5ncysrO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoJ3BpbmcnKTtcbiAgICAgICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ3BvbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVuY3kgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVuY2llcy5wdXNoKGxhdGVuY3kpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGluZ3MgPj0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lb3V0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVkaWFuID0gbGF0ZW5jaWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZWRpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCdTb2NrZXQgdGltZW91dCcpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lb3V0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXNvbHZlKC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIud2FybignRXJyb3Igb3BlbmluZyBzb2NrZXQnKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBwaW5nKCk7XG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwaW5nLCAxMDAwKTtcbiAgICAgICAgICAgIHRpbWVvdXRJbnRlcnZhbCA9IHNldEludGVydmFsKHRpbWVvdXQsIDEwMDAwKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmNsYXNzIFRyYWNrQVBJIHtcbiAgICBzdGF0aWMgdHJhY2tPbmNlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGxldCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGFjY3VyYWN5LCBkZXNpcmVkQWNjdXJhY3ksIGZyYXVkIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICAvLyBpZiBsYXRpdHVkZSAmIGxvbmdpdHVkZSBhcmUgbm90IHByb3ZpZGVkLFxuICAgICAgICAgICAgLy8gdHJ5IGFuZCByZXRyaWV2ZSBkZXZpY2UgbG9jYXRpb24gKHdpbGwgcHJvbXB0IGZvciBsb2NhdGlvbiBwZXJtaXNzaW9ucylcbiAgICAgICAgICAgIGlmICghbGF0aXR1ZGUgfHwgIWxvbmdpdHVkZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZUxvY2F0aW9uID0geWllbGQgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbih7IGRlc2lyZWRBY2N1cmFjeSB9KTtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZSA9IGRldmljZUxvY2F0aW9uLmxhdGl0dWRlO1xuICAgICAgICAgICAgICAgIGxvbmdpdHVkZSA9IGRldmljZUxvY2F0aW9uLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICBhY2N1cmFjeSA9IGRldmljZUxvY2F0aW9uLmFjY3VyYWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG9jYXRpb24gYXV0aG9yaXphdGlvblxuICAgICAgICAgICAgbGV0IGxvY2F0aW9uQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb25BdXRob3JpemF0aW9uID0geWllbGQgTmF2aWdhdG9yLmdldFBlcm1pc3Npb25TdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybihgTG9jYXRpb24gYXV0aG9yaXphdGlvbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZXIgaW5kZW50aWZpY2F0aW9uIGZpZWxkc1xuICAgICAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZCB8fCBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5VU0VSX0lEKTtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcGFyYW1zLmRldmljZUlkIHx8IERldmljZS5nZXREZXZpY2VJZCgpO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFsbElkID0gcGFyYW1zLmluc3RhbGxJZCB8fCBEZXZpY2UuZ2V0SW5zdGFsbElkKCk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBTZXNzaW9uLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9IHBhcmFtcy5kZXZpY2VUeXBlIHx8ICdXZWInO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb24gfHwgU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgbGV0IHRpbWVab25lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybihgRXJyb3IgZ2V0dGluZyB0aW1lIHpvbmU6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzYXZlIHVzZXJJZCBmb3IgdHJpcCB0cmFja2luZ1xuICAgICAgICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndXNlcklkIG5vdCBwcm92aWRlZCBmb3IgdHJhY2tPbmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuVVNFUl9JRCwgdXNlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyIGluZm9cbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhIHx8IFN0b3JhZ2UuZ2V0SlNPTihTdG9yYWdlLk1FVEFEQVRBKTtcbiAgICAgICAgICAgIC8vIHRyaXBzXG4gICAgICAgICAgICBjb25zdCB0cmlwT3B0aW9ucyA9IHBhcmFtcy50cmlwT3B0aW9ucyB8fCBUcmlwc0FQSS5nZXRUcmlwT3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKHRyaXBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdHJpcE9wdGlvbnMudmVyc2lvbiA9ICcyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgbG9jYXRpb25BdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgIGFjY3VyYWN5LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGRldmljZUlkLFxuICAgICAgICAgICAgICAgIGRldmljZVR5cGUsIGZvcmVncm91bmQ6IHRydWUsIGluc3RhbGxJZCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLCBzZGtWZXJzaW9uOiBTREtfVkVSU0lPTiwgc3RvcHBlZDogdHJ1ZSwgdXNlcklkLFxuICAgICAgICAgICAgICAgIHRyaXBPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVab25lIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKGZyYXVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdCA9ICdodHRwczovL2FwaS12ZXJpZmllZC5yYWRhci5pbyc7XG4gICAgICAgICAgICAgICAgY29uc3QgcGluZ0hvc3QgPSAncGluZy5yYWRhci12ZXJpZnkuY29tJztcbiAgICAgICAgICAgICAgICBjb25zdCBsYW5nID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdzID0gbmF2aWdhdG9yLmxhbmd1YWdlcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRrIH0gPSB5aWVsZCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnY29uZmlnJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLVJhZGFyLURlc2t0b3AtRGV2aWNlLVR5cGUnOiAnV2ViJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgc2NsVmFsID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IGNzbFZhbCA9IC0xO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzY2xSZXMsIGNzbF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGBodHRwczovLyR7cGluZ0hvc3R9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGluZyhgd3NzOi8vJHtwaW5nSG9zdH1gKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NsIH0gPSBzY2xSZXM7XG4gICAgICAgICAgICAgICAgICAgIHNjbFZhbCA9IHNjbDtcbiAgICAgICAgICAgICAgICAgICAgY3NsVmFsID0gY3NsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcsIHNlbmQgc2NsID0gLTEgYW5kIGNzbCA9IC0xXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm9keSksIHsgc2NsOiBzY2xWYWwsIGNzbDogY3NsVmFsLCBsYW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3MgfSkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxVG9rZW4gPSB5aWVsZCBzaWduSldUKHBheWxvYWQsIGRrKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAndHJhY2snLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogcmVxVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLVJhZGFyLUJvZHktSXMtVG9rZW4nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcgJiYgcmVzcG9uc2UgJiYgcmVzcG9uc2UudXNlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnVzZXIubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnVzZXIubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS51c2VyLm1ldGFkYXRhWydyYWRhcjpkZWJ1ZyddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NsVmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NsVmFsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeyB1c2VyLCBldmVudHMsIHRva2VuLCBleHBpcmVzQXQsIGV4cGlyZXNJbiwgcGFzc2VkLCBmYWlsdXJlUmVhc29ucywgX2lkIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3kgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwaXJlc0F0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IG5ldyBEYXRlKGV4cGlyZXNBdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZVJlYXNvbnMsXG4gICAgICAgICAgICAgICAgICAgIF9pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFja1JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAndHJhY2snLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgZXZlbnRzIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0geyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSB9O1xuICAgICAgICAgICAgY29uc3QgdHJhY2tSZXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0cmFja1Jlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrUmVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmxldCB0b2tlblRpbWVvdXRJZCA9IG51bGw7XG5sZXQgdG9rZW5DYWxsYmFjayA9IG51bGw7XG5sZXQgbGFzdFRva2VuID0gbnVsbDtcbmxldCBsYXN0VG9rZW5Ob3cgPSAwO1xubGV0IGV4cGVjdGVkQ291bnRyeUNvZGUgPSBudWxsO1xubGV0IGV4cGVjdGVkU3RhdGVDb2RlID0gbnVsbDtcbmNsYXNzIFZlcmlmeUFQSSB7XG4gICAgc3RhdGljIHRyYWNrVmVyaWZpZWQocGFyYW1zLCBlbmNyeXB0ZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIC8vIHVzZXIgaW5kZW50aWZpY2F0aW9uIGZpZWxkc1xuICAgICAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZCB8fCBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5VU0VSX0lEKTtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcGFyYW1zLmRldmljZUlkIHx8IERldmljZS5nZXREZXZpY2VJZCgpO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFsbElkID0gcGFyYW1zLmluc3RhbGxJZCB8fCBEZXZpY2UuZ2V0SW5zdGFsbElkKCk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBTZXNzaW9uLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb24gfHwgU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgLy8gc2F2ZSB1c2VySWRcbiAgICAgICAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ3VzZXJJZCBub3QgcHJvdmlkZWQgZm9yIHRyYWNrVmVyaWZpZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5VU0VSX0lELCB1c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXIgaW5mb1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgfHwgU3RvcmFnZS5nZXRKU09OKFN0b3JhZ2UuTUVUQURBVEEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCwgZm9yZWdyb3VuZDogdHJ1ZSwgaW5zdGFsbElkLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSwgc2RrVmVyc2lvbjogU0RLX1ZFUlNJT04sIHN0b3BwZWQ6IHRydWUsIHVzZXJJZCxcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudHJ5Q29kZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZFN0YXRlQ29kZSB9KTtcbiAgICAgICAgICAgIGxldCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICAgICAgY29uc3QgYXBwbGUgPSB1c2VyQWdlbnQgJiYgKHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtYWMnKSB8fCB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaXBob25lJykgfHwgdXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2lwb2QnKSB8fCB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaXBhZCcpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICd2ZXJpZnknLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICAgICAgaG9zdDogYXBwbGUgPyAnaHR0cHM6Ly9yYWRhci12ZXJpZnkuY29tOjUyNTE2JyA6ICdodHRwOi8vbG9jYWxob3N0OjUyNTE2JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHsgdXNlciwgZXZlbnRzLCB0b2tlbiwgZXhwaXJlc0F0LCBleHBpcmVzSW4sIHBhc3NlZCwgZmFpbHVyZVJlYXNvbnMsIF9pZCB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgbG9jYXRpb247XG4gICAgICAgICAgICBpZiAodXNlciAmJiB1c2VyLmxvY2F0aW9uICYmIHVzZXIubG9jYXRpb24uY29vcmRpbmF0ZXMgJiYgdXNlci5sb2NhdGlvbkFjY3VyYWN5KSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB1c2VyLmxvY2F0aW9uLmNvb3JkaW5hdGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHVzZXIubG9jYXRpb24uY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFjY3VyYWN5OiB1c2VyLmxvY2F0aW9uQWNjdXJhY3ksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBpcmVzQXQpIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBuZXcgRGF0ZShleHBpcmVzQXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhY2tSZXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIGV4cGlyZXNJbixcbiAgICAgICAgICAgICAgICBwYXNzZWQsXG4gICAgICAgICAgICAgICAgZmFpbHVyZVJlYXNvbnMsXG4gICAgICAgICAgICAgICAgX2lkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRyYWNrUmVzO1xuICAgICAgICAgICAgbGFzdFRva2VuTm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBpZiAodG9rZW5DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRva2VuQ2FsbGJhY2sodHJhY2tSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrUmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0VHJhY2tpbmdWZXJpZmllZChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvVHJhY2tWZXJpZmllZCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja1JlcyA9IHlpZWxkIHRoaXMudHJhY2tWZXJpZmllZCh7fSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnRlcnZhbCB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGxldCBleHBpcmVzSW4gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtaW5JbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja1Jlcykge1xuICAgICAgICAgICAgICAgICAgICBleHBpcmVzSW4gPSAodHJhY2tSZXMuZXhwaXJlc0luIHx8IGV4cGlyZXNJbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGV4cGlyZXNJbiBpcyBzaG9ydGVyIHRoYW4gaW50ZXJ2YWwsIG92ZXJyaWRlIGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgIG1pbkludGVydmFsID0gTWF0aC5taW4oZXhwaXJlc0luLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlLXJlcXVlc3QgZWFybHkgdG8gbWF4aW1pemUgdGhlIGxpa2VsaWhvb2QgdGhhdCBhIGNhY2hlZCB0b2tlbiBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAobWluSW50ZXJ2YWwgPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5JbnRlcnZhbCA9IG1pbkludGVydmFsIC0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1pbiBpbnRlcnZhbCBpcyAxMCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgaWYgKG1pbkludGVydmFsIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbWluSW50ZXJ2YWwgPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuVGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b2tlblRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuVGltZW91dElkID0gc2V0VGltZW91dChkb1RyYWNrVmVyaWZpZWQsIG1pbkludGVydmFsICogMTAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvVHJhY2tWZXJpZmllZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHN0b3BUcmFja2luZ1ZlcmlmaWVkKCkge1xuICAgICAgICBpZiAodG9rZW5UaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b2tlblRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldFZlcmlmaWVkTG9jYXRpb25Ub2tlbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbkVsYXBzZWQgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0VG9rZW5Ob3cpIC8gMTAwMDtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuRWxhcHNlZCA8IChsYXN0VG9rZW4uZXhwaXJlc0luIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tWZXJpZmllZCh7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0RXhwZWN0ZWRKdXJpc2RpY3Rpb24oY291bnRyeUNvZGUsIHN0YXRlQ29kZSkge1xuICAgICAgICBleHBlY3RlZENvdW50cnlDb2RlID0gY291bnRyeUNvZGUgfHwgbnVsbDtcbiAgICAgICAgZXhwZWN0ZWRTdGF0ZUNvZGUgPSBzdGF0ZUNvZGUgfHwgbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIG9uVG9rZW5VcGRhdGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRva2VuQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG59XG5cbmNvbnN0IGlzU2VjcmV0S2V5ID0gKGtleSkgPT4gKGtleS5pbmNsdWRlcygnX3NrXycpKTtcbmNvbnN0IGlzTGl2ZUtleSA9IChrZXkpID0+IChrZXkuaW5jbHVkZXMoJ19saXZlXycpKTtcbmxldCBSYWRhciQxID0gY2xhc3MgUmFkYXIge1xuICAgIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICAgICAgcmV0dXJuIFNES19WRVJTSU9OO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdGlhbGl6ZShwdWJsaXNoYWJsZUtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghcHVibGlzaGFibGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWRhclB1Ymxpc2hhYmxlS2V5RXJyb3IoJ1B1Ymxpc2hhYmxlIGtleSByZXF1aXJlZCBpbiBpbml0aWFsaXphdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWNyZXRLZXkocHVibGlzaGFibGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yKCdTZWNyZXQga2V5cyBhcmUgbm90IGFsbG93ZWQuIFBsZWFzZSB1c2UgeW91ciBSYWRhciBwdWJsaXNoYWJsZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgc2V0dGluZ3MgaW4gZ2xvYmFsIGNvbmZpZ1xuICAgICAgICBjb25zdCBsaXZlID0gaXNMaXZlS2V5KHB1Ymxpc2hhYmxlS2V5KTtcbiAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBsaXZlID8gJ2Vycm9yJyA6ICdpbmZvJztcbiAgICAgICAgY29uc3QgZGVidWcgPSAhbGl2ZTtcbiAgICAgICAgY29uc3QgcmFkYXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihDb25maWcuZGVmYXVsdE9wdGlvbnMsIHtcbiAgICAgICAgICAgIHB1Ymxpc2hhYmxlS2V5LFxuICAgICAgICAgICAgbGl2ZSxcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgZGVidWcsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBDb25maWcuc2V0dXAocmFkYXJPcHRpb25zKTtcbiAgICAgICAgTG9nZ2VyLmluZm8oYGluaXRpYWxpemVkIHdpdGggJHtsaXZlID8gJ2xpdmUnIDogJ3Rlc3QnfSBwdWJsaXNoYWJsZUtleS5gKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIExvZ2dlci5pbmZvKGB1c2luZyBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEUoamFzb25sKTogdGhpcyBhbGxvd3MgdXMgdG8gcnVuIGplc3QgdGVzdHNcbiAgICAgICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gbW9jayB0aGUgQ29uZmlnQVBJLmdldENvbmZpZyBjYWxsXG4gICAgICAgIGlmICghKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5SQURBUl9URVNUX0VOVikpIHtcbiAgICAgICAgICAgIENvbmZpZ0FQSS5nZXRDb25maWcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY2xlYXIoKSB7XG4gICAgICAgIENvbmZpZy5jbGVhcigpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlb2ZlbmNpbmcgUGxhdGZvcm1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIHN0YXRpYyBzZXRVc2VySWQodXNlcklkKSB7XG4gICAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgICAgICBTdG9yYWdlLnJlbW92ZUl0ZW0oU3RvcmFnZS5VU0VSX0lEKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5VU0VSX0lELCBTdHJpbmcodXNlcklkKS50cmltKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0RGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgU3RvcmFnZS5yZW1vdmVJdGVtKFN0b3JhZ2UuREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLkRFU0NSSVBUSU9OLCBTdHJpbmcoZGVzY3JpcHRpb24pLnRyaW0oKSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICBTdG9yYWdlLnJlbW92ZUl0ZW0oU3RvcmFnZS5NRVRBREFUQSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuTUVUQURBVEEsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5hdmlnYXRvci5nZXRDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9XG4gICAgc3RhdGljIHRyYWNrT25jZShwYXJhbXMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNrQVBJLnRyYWNrT25jZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgQ29uZmlnQVBJLmdldENvbmZpZyhwYXJhbXMpOyAvLyBjYWxsIHdpdGggdXBkYXRlZCBwZXJtaXNzaW9uc1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0cmFja1ZlcmlmaWVkKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBWZXJpZnlBUEkudHJhY2tWZXJpZmllZChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnRUcmFja2luZ1ZlcmlmaWVkKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gVmVyaWZ5QVBJLnN0YXJ0VHJhY2tpbmdWZXJpZmllZChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RvcFRyYWNraW5nVmVyaWZpZWQoKSB7XG4gICAgICAgIHJldHVybiBWZXJpZnlBUEkuc3RvcFRyYWNraW5nVmVyaWZpZWQoKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFZlcmlmaWVkTG9jYXRpb25Ub2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFZlcmlmeUFQSS5nZXRWZXJpZmllZExvY2F0aW9uVG9rZW4oKTtcbiAgICB9XG4gICAgc3RhdGljIHNldEV4cGVjdGVkSnVyaXNkaWN0aW9uKGNvdW50cnlDb2RlLCBzdGF0ZUNvZGUpIHtcbiAgICAgICAgVmVyaWZ5QVBJLnNldEV4cGVjdGVkSnVyaXNkaWN0aW9uKGNvdW50cnlDb2RlLCBzdGF0ZUNvZGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udGV4dChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRBUEkuZ2V0Q29udGV4dChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0VHJpcE9wdGlvbnModHJpcE9wdGlvbnMpIHtcbiAgICAgICAgVHJpcHNBUEkuc2V0VHJpcE9wdGlvbnModHJpcE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgY2xlYXJUcmlwT3B0aW9ucygpIHtcbiAgICAgICAgVHJpcHNBUEkuY2xlYXJUcmlwT3B0aW9ucygpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VHJpcE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBUcmlwc0FQSS5nZXRUcmlwT3B0aW9ucygpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnRUcmlwKHRyaXBPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBUcmlwc0FQSS5zdGFydFRyaXAodHJpcE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlVHJpcCh0cmlwT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gVHJpcHNBUEkudXBkYXRlVHJpcCh0cmlwT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wbGV0ZVRyaXAoKSB7XG4gICAgICAgIHJldHVybiBUcmlwc0FQSS5jb21wbGV0ZVRyaXAoKTtcbiAgICB9XG4gICAgc3RhdGljIGNhbmNlbFRyaXAoKSB7XG4gICAgICAgIHJldHVybiBUcmlwc0FQSS5jYW5jZWxUcmlwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBsb2dDb252ZXJzaW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQ29udmVyc2lvbnNBUEkubG9nQ29udmVyc2lvbihwYXJhbXMpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIExpc3RlbmVyc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgc3RhdGljIG9uVG9rZW5VcGRhdGVkKGNhbGxiYWNrKSB7XG4gICAgICAgIFZlcmlmeUFQSS5vblRva2VuVXBkYXRlZChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWFwcyBQbGF0Zm9ybVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgc3RhdGljIGZvcndhcmRHZW9jb2RlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gR2VvY29kaW5nLmZvcndhcmRHZW9jb2RlKHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyByZXZlcnNlR2VvY29kZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIEdlb2NvZGluZy5yZXZlcnNlR2VvY29kZShwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXBHZW9jb2RlKCkge1xuICAgICAgICByZXR1cm4gR2VvY29kaW5nLmlwR2VvY29kZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgYXV0b2NvbXBsZXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLmF1dG9jb21wbGV0ZShwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoR2VvZmVuY2VzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLnNlYXJjaEdlb2ZlbmNlcyhwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VhcmNoUGxhY2VzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLnNlYXJjaFBsYWNlcyhwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRhdGVBZGRyZXNzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQWRkcmVzc2VzQVBJLnZhbGlkYXRlQWRkcmVzcyhwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZGlzdGFuY2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBSb3V0aW5nQVBJLmRpc3RhbmNlKHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBtYXRyaXgocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBSb3V0aW5nQVBJLm1hdHJpeChwYXJhbXMpO1xuICAgIH1cbn07XG5cbmNsYXNzIFJhZGFyRmVhdHVyZU1vdXNlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGZlYXR1cmUsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICB9XG59XG5jbGFzcyBSYWRhck1hcEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1hcCwgZmVhdHVyZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3NvdXJjZUlkcyA9IFtdO1xuICAgICAgICB0aGlzLl9sYXllcklkcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gKChfYSA9IGZlYXR1cmUuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGBmZWF0dXJlLSR7RGF0ZS5ub3coKX1gKS50b1N0cmluZygpO1xuICAgICAgICAvLyBjaGVjayBmb3IgZHVwbGljYXRlIElEc1xuICAgICAgICAobWFwLmdldEZlYXR1cmVzKCkgfHwgW10pLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSYWRhck1hcEZlYXR1cmU6IGZlYXR1cmUgd2l0aCBpZCAke3RoaXMuaWR9IGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IGZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgdGhpcy5fZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICAvLyByZW1vdmUgbGF5ZXJzXG4gICAgICAgIHRoaXMuX2xheWVySWRzLmZvckVhY2goKGxheWVySWQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAuZ2V0TGF5ZXIobGF5ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1vdmUgc291cmNlXG4gICAgICAgIHRoaXMuX3NvdXJjZUlkcy5mb3JFYWNoKChzb3VyY2VJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcC5nZXRTb3VyY2Uoc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZVNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gbWFwXG4gICAgICAgIHRoaXMuX21hcC5fZmVhdHVyZXMgPSB0aGlzLl9tYXAuX2ZlYXR1cmVzLmZpbHRlcigob3RoZXIpID0+IG90aGVyLmlkICE9PSB0aGlzLmlkKTtcbiAgICB9XG4gICAgLy8gcmVnaXN0ZXIgZXZlbnRzIHdpdGggZmVhdHVyZSBsYXllclxuICAgIG9uKGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uKGV2ZW50VHlwZSwgdGhpcy5pZCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgUmFkYXJGZWF0dXJlTW91c2VFdmVudChldmVudFR5cGUsIHRoaXMsIGV2ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgcG9pbnRlciBjdXJzb3IgaWYgZmVhdHVyZSBpcyBjbGlja2FibGVcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZWVudGVyJywgdGhpcy5pZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignbW91c2VsZWF2ZScsIHRoaXMuaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L3BvbHlsaW5lXG4gKlxuICogRGVjb2RlcyB0byBhIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBjb29yZGluYXRlcyBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIGFkYXB0ZWQgZnJvbSB0aGUgaW1wbGVtZW50YXRpb24gaW4gUHJvamVjdC1PU1JNLlxuICpcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvamVjdC1PU1JNL29zcm0tZnJvbnRlbmQvYmxvYi9tYXN0ZXIvV2ViQ29udGVudC9yb3V0aW5nL09TUk0uUm91dGluZ0dlb21ldHJ5LmpzXG4gKlxuICovXG5jb25zdCBkZWNvZGVQb2x5bGluZSA9IChzdHIsIHByZWNpc2lvbiA9IDYpID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBsYXQgPSAwO1xuICAgIGxldCBsbmcgPSAwO1xuICAgIGxldCBjb29yZGluYXRlcyA9IFtdO1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgbGV0IGJ5dGUgPSBudWxsO1xuICAgIGxldCBsYXRpdHVkZUNoYW5nZTtcbiAgICBsZXQgbG9uZ2l0dWRlQ2hhbmdlO1xuICAgIGxldCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDYpO1xuICAgIC8vIENvb3JkaW5hdGVzIGhhdmUgdmFyaWFibGUgbGVuZ3RoIHdoZW4gZW5jb2RlZCwgc28ganVzdCBrZWVwXG4gICAgLy8gdHJhY2sgb2Ygd2hldGhlciB3ZSd2ZSBoaXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLiBJbiBlYWNoXG4gICAgLy8gbG9vcCBpdGVyYXRpb24sIGEgc2luZ2xlIGNvb3JkaW5hdGUgaXMgZGVjb2RlZC5cbiAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIC8vIFJlc2V0IHNoaWZ0LCByZXN1bHQsIGFuZCBieXRlXG4gICAgICAgIGJ5dGUgPSBudWxsO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGJ5dGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCsrKSAtIDYzO1xuICAgICAgICAgICAgcmVzdWx0IHw9IChieXRlICYgMHgxZikgPDwgc2hpZnQ7XG4gICAgICAgICAgICBzaGlmdCArPSA1O1xuICAgICAgICB9IHdoaWxlIChieXRlID49IDB4MjApO1xuICAgICAgICBsYXRpdHVkZUNoYW5nZSA9IHJlc3VsdCAmIDEgPyB+KHJlc3VsdCA+PiAxKSA6IHJlc3VsdCA+PiAxO1xuICAgICAgICBzaGlmdCA9IHJlc3VsdCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGJ5dGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCsrKSAtIDYzO1xuICAgICAgICAgICAgcmVzdWx0IHw9IChieXRlICYgMHgxZikgPDwgc2hpZnQ7XG4gICAgICAgICAgICBzaGlmdCArPSA1O1xuICAgICAgICB9IHdoaWxlIChieXRlID49IDB4MjApO1xuICAgICAgICBsb25naXR1ZGVDaGFuZ2UgPSByZXN1bHQgJiAxID8gfihyZXN1bHQgPj4gMSkgOiByZXN1bHQgPj4gMTtcbiAgICAgICAgbGF0ICs9IGxhdGl0dWRlQ2hhbmdlO1xuICAgICAgICBsbmcgKz0gbG9uZ2l0dWRlQ2hhbmdlO1xuICAgICAgICBjb29yZGluYXRlcy5wdXNoKFtsbmcgLyBmYWN0b3IsIGxhdCAvIGZhY3Rvcl0pO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG4vLyByZW1vdmUgZmllbGRzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmcm9tIG9iamVjdFxuLy8gKHRvcC1sZXZlbCBvbmx5KVxuY29uc3QgZmlsdGVyVW5kZWZpbmVkID0gKG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKG9iamVjdCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG4vLyBkZWVwIG1lcmdlIG5lc3RlZCBvYmplY3RzIC0gcmV0dXJucyBhIG5ldyBvYmplY3Rcbi8vIChhcnJheXMgYXJlIGNvbmNhdGVuYXRlZClcbmNvbnN0IG1lcmdlRGVlcCA9ICh0YXJnZXQsIHNvdXJjZSA9IHt9KSA9PiB7XG4gICAgbGV0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2Vba2V5XSkgJiYga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSAmJiBBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB0YXJnZXRba2V5XS5jb25jYXQoc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgZGVmYXVsdExpbmVPcHRpb25zID0ge1xuICAgIHBhaW50OiB7XG4gICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAgICdsaW5lLWNvbG9yJzogJyMwMDAyNTcnLFxuICAgICAgICAnbGluZS13aWR0aCc6IDQsXG4gICAgICAgICdib3JkZXItY29sb3InOiAnI0ZGRkZGRicsXG4gICAgICAgICdib3JkZXItd2lkdGgnOiAyLFxuICAgIH1cbn07XG5jbGFzcyBSYWRhckxpbmVGZWF0dXJlIGV4dGVuZHMgUmFkYXJNYXBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXAsIGZlYXR1cmUsIGxpbmVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1hcCwgZmVhdHVyZSk7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVJZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZURlZXAoZGVmYXVsdExpbmVPcHRpb25zLCBsaW5lT3B0aW9ucyk7XG4gICAgICAgIC8vIHVzZSBhIGNhbGxiYWNrIHRvIGFjY291bnQgZm9yIHRoZSBhc3luYyBsb2FkaW5nIG9mIHRoZSBtYXBcbiAgICAgICAgY29uc3QgYWRkRmVhdHVyZVRvTWFwID0gKCkgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5wYWludCA9IG9wdGlvbnMucGFpbnQgfHwge307XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIGZvciBmZWF0dXJlXG4gICAgICAgICAgICBtYXAuYWRkU291cmNlKGZlYXR1cmVJZCwgeyB0eXBlOiAnZ2VvanNvbicsIGRhdGE6IGZlYXR1cmUgfSk7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VJZHMucHVzaChmZWF0dXJlSWQpO1xuICAgICAgICAgICAgLy8gYWRkIGJvcmRlciBsYXllciBpZiBib3JkZXIgc3R5bGluZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWludFsnbGluZS13aWR0aCddICYmIG9wdGlvbnMucGFpbnRbJ2JvcmRlci13aWR0aCddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyTGF5ZXJJZCA9IGAke2ZlYXR1cmVJZH0tYm9yZGVyYDtcbiAgICAgICAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IG9wdGlvbnMucGFpbnRbJ2xpbmUtd2lkdGgnXSArIG9wdGlvbnMucGFpbnRbJ2JvcmRlci13aWR0aCddO1xuICAgICAgICAgICAgICAgIG1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBib3JkZXJMYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZlYXR1cmVJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lLWNhcCc6IG9wdGlvbnMucGFpbnRbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhaW50OiBmaWx0ZXJVbmRlZmluZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBvcHRpb25zLnBhaW50Wydib3JkZXItY29sb3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiBvcHRpb25zLnBhaW50Wydib3JkZXItb3BhY2l0eSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiBib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZHMucHVzaChib3JkZXJMYXllcklkKTsgLy8gYm9yZGVyIGxheWVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5lLWxheWVyXG4gICAgICAgICAgICBtYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGlkOiBmZWF0dXJlSWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBmZWF0dXJlSWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAnbGluZS1jYXAnOiBvcHRpb25zLnBhaW50WydsaW5lLWNhcCddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFpbnQ6IGZpbHRlclVuZGVmaW5lZCh7XG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWNvbG9yJzogb3B0aW9ucy5wYWludFsnbGluZS1jb2xvciddLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS13aWR0aCc6IG9wdGlvbnMucGFpbnRbJ2xpbmUtd2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IG9wdGlvbnMucGFpbnRbJ2xpbmUtb3BhY2l0eSddLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1vZmZzZXQnOiBvcHRpb25zLnBhaW50WydsaW5lLW9mZnNldCddLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1ibHVyJzogb3B0aW9ucy5wYWludFsnbGluZS1ibHVyJ10sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWRhc2hhcnJheSc6IG9wdGlvbnMucGFpbnRbJ2xpbmUtZGFzaGFycmF5J10sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWdhcC13aWR0aCc6IG9wdGlvbnMucGFpbnRbJ2xpbmUtZ2FwLXdpZHRoJ10sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWdyYWRpZW50Jzogb3B0aW9ucy5wYWludFsnbGluZS1ncmFkaWVudCddLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9sYXllcklkcy5wdXNoKGZlYXR1cmVJZCk7IC8vIGxpbmUgbGF5ZXJcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZW5zdXJlIG1hcCBpcyByZWFkeSBiZWZvcmUgbW9kaWZ5aW5nIHNvdXJjZSBhbmQgbGF5ZXJzXG4gICAgICAgIGlmIChtYXAubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGFkZEZlYXR1cmVUb01hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwLm9uY2UoJ2RhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkRmVhdHVyZVRvTWFwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qb2x5bGluZShtYXAsIHBvbHlsaW5lLCBwb2x5bGluZU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZUlkID0gKHBvbHlsaW5lT3B0aW9ucyA9PT0gbnVsbCB8fCBwb2x5bGluZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlsaW5lT3B0aW9ucy5pZCkgfHwgYHBvbHlsaW5lLWZlYXR1cmUtJHtEYXRlLm5vdygpfWA7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZGVjb2RlUG9seWxpbmUocG9seWxpbmUsIHBvbHlsaW5lT3B0aW9ucyA9PT0gbnVsbCB8fCBwb2x5bGluZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlsaW5lT3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICAgICAgaWQ6IGZlYXR1cmVJZCxcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IChwb2x5bGluZU9wdGlvbnMgPT09IG51bGwgfHwgcG9seWxpbmVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2x5bGluZU9wdGlvbnMucHJvcGVydGllcykgfHwge30sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpbmVGZWF0dXJlID0gbmV3IFJhZGFyTGluZUZlYXR1cmUobWFwLCBmZWF0dXJlLCBwb2x5bGluZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGluZUZlYXR1cmU7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0UG9seWdvbk9wdGlvbnMgPSB7XG4gICAgcGFpbnQ6IHtcbiAgICAgICAgJ2ZpbGwtY29sb3InOiAnI0ZGNkYwMCcsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAwLjMsXG4gICAgICAgICdib3JkZXItY29sb3InOiAnI0ZGNkYwMCcsXG4gICAgICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgICAgICdib3JkZXItd2lkdGgnOiAyLFxuICAgIH1cbn07XG5jbGFzcyBSYWRhclBvbHlnb25GZWF0dXJlIGV4dGVuZHMgUmFkYXJNYXBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXAsIGZlYXR1cmUsIHBvbHlnb25PcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1hcCwgZmVhdHVyZSk7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVJZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZURlZXAoZGVmYXVsdFBvbHlnb25PcHRpb25zLCBwb2x5Z29uT3B0aW9ucyk7XG4gICAgICAgIC8vIHVzZSBhIGNhbGxiYWNrIHRvIGFjY291bnQgZm9yIHRoZSBhc3luYyBsb2FkaW5nIG9mIHRoZSBtYXBcbiAgICAgICAgY29uc3QgYWRkRmVhdHVyZVRvTWFwID0gKCkgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5wYWludCA9IG9wdGlvbnMucGFpbnQgfHwge307XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIGZvciBmZWF0dXJlXG4gICAgICAgICAgICBtYXAuYWRkU291cmNlKGZlYXR1cmVJZCwgeyB0eXBlOiAnZ2VvanNvbicsIGRhdGE6IGZlYXR1cmUgfSk7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VJZHMucHVzaChmZWF0dXJlSWQpO1xuICAgICAgICAgICAgLy8gcG9seWdvbi1sYXllclxuICAgICAgICAgICAgbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICAgICBpZDogZmVhdHVyZUlkLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogZmVhdHVyZUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICAgICAgICAgIHBhaW50OiBmaWx0ZXJVbmRlZmluZWQoe1xuICAgICAgICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IG9wdGlvbnMucGFpbnRbJ2ZpbGwtY29sb3InXSxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wdGlvbnMucGFpbnRbJ2ZpbGwtb3BhY2l0eSddLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9sYXllcklkcy5wdXNoKGZlYXR1cmVJZCk7XG4gICAgICAgICAgICAvLyBib3JkZXIgbGF5ZXJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhaW50Wydib3JkZXItY29sb3InXSAmJiBvcHRpb25zLnBhaW50Wydib3JkZXItd2lkdGgnXSAmJiBvcHRpb25zLnBhaW50Wydib3JkZXItb3BhY2l0eSddKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlckxheWVySWQgPSBgJHtmZWF0dXJlSWR9LWJvcmRlcmA7XG4gICAgICAgICAgICAgICAgbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGJvcmRlckxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZmVhdHVyZUlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDoge30sXG4gICAgICAgICAgICAgICAgICAgIHBhaW50OiBmaWx0ZXJVbmRlZmluZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBvcHRpb25zLnBhaW50Wydib3JkZXItY29sb3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiBvcHRpb25zLnBhaW50Wydib3JkZXItb3BhY2l0eSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiBvcHRpb25zLnBhaW50Wydib3JkZXItd2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZHMucHVzaChib3JkZXJMYXllcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZW5zdXJlIG1hcCBpcyByZWFkeSBiZWZvcmUgbW9kaWZ5aW5nIHNvdXJjZSBhbmQgbGF5ZXJzXG4gICAgICAgIGlmIChtYXAubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGFkZEZlYXR1cmVUb01hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwLm9uY2UoJ2RhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkRmVhdHVyZVRvTWFwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IFJBREFSX0xPR09fVVJMID0gJ2h0dHBzOi8vYXBpLnJhZGFyLmlvL21hcHMvc3RhdGljL2ltYWdlcy9sb2dvLnN2Zyc7XG5jbGFzcyBSYWRhckxvZ29Db250cm9sIHtcbiAgICBvbkFkZCgpIHtcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBSQURBUl9MT0dPX1VSTDtcbiAgICAgICAgaW1nLmFsdCA9ICdSYWRhciBNYXBzIFBsYXRmb3JtJztcbiAgICAgICAgdGhpcy5saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB0aGlzLmxpbmsuaWQgPSAncmFkYXItbWFwLWxvZ28nO1xuICAgICAgICB0aGlzLmxpbmsuaHJlZiA9ICdodHRwczovL3JhZGFyLmNvbT9yZWY9cG93ZXJlZF9ieV9yYWRhcic7XG4gICAgICAgIHRoaXMubGluay50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgdGhpcy5saW5rLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbms7XG4gICAgfVxuICAgIG9uUmVtb3ZlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMubGluaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuY29uc3QgYXBwZW5kID0gKGRlc3QsIHNyYykgPT4ge1xuICAgIHNyYy5mb3JFYWNoKChjb29yZCkgPT4ge1xuICAgICAgICBkZXN0LnB1c2goY29vcmQpO1xuICAgIH0pO1xufTtcbi8vIHJldHVybiBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMgaW4gYSBmZWF0dXJlXG5jb25zdCBnZXRDb29yZHMgPSAoZmVhdHVyZSkgPT4ge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5O1xuICAgIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgICAgICBhcHBlbmQoY29vcmRpbmF0ZXMsIGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goY29vcmRzID0+IGFwcGVuZChjb29yZGluYXRlcywgY29vcmRzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGNvb3JkcyA9PiBhcHBlbmQoY29vcmRpbmF0ZXMsIGNvb3JkcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufTtcbi8vIHJldHVybiBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhIGxpc3Qgb2YgZmVhdHVyZVxuY29uc3QgZ2V0QWxsQ29vcmRzID0gKGZlYXR1cmVzKSA9PiB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICAoZmVhdHVyZXMgfHwgW10pLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgY29uc3QgY29vcmRzID0gZ2V0Q29vcmRzKGZlYXR1cmUpO1xuICAgICAgICBjb29yZHMuZm9yRWFjaCgoY29vcmQpID0+IHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG5jb25zdCBERUZBVUxUX1NUWUxFID0gJ3JhZGFyLWRlZmF1bHQtdjEnO1xuY29uc3QgUkFEQVJfU1RZTEVTID0gW1xuICAgICdyYWRhci1kZWZhdWx0LXYxJyxcbiAgICAncmFkYXItbGlnaHQtdjEnLFxuICAgICdyYWRhci1kYXJrLXYxJyxcbl07XG4vLyBSYWRhciBzcGVjaWZpYyBjb25maWdzXG5jb25zdCBkZWZhdWx0UmFkYXJNYXBPcHRpb25zID0ge1xuICAgIHNob3dab29tQ29udHJvbHM6IHRydWUsXG59O1xuY29uc3QgZGVmYXVsdE1hcGxpYnJlT3B0aW9ucyA9IHtcbiAgICBtaW5ab29tOiAxLFxuICAgIG1heFpvb206IDIwLFxuICAgIGF0dHJpYnV0aW9uQ29udHJvbDogZmFsc2UsXG4gICAgZHJhZ1JvdGF0ZTogZmFsc2UsXG4gICAgdG91Y2hQaXRjaDogZmFsc2UsXG4gICAgbWFwbGlicmVMb2dvOiBmYWxzZSxcbn07XG5jb25zdCBkZWZhdWx0Rml0TWFya2Vyc09wdGlvbnMgPSB7XG4gICAgcGFkZGluZzogNTAsXG59O1xuY29uc3QgY3JlYXRlU3R5bGVVUkwgPSAob3B0aW9ucywgbWFwT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gbWFwT3B0aW9ucy5zdHlsZSB8fCBERUZBVUxUX1NUWUxFO1xuICAgIGxldCB1cmwgPSBgJHtvcHRpb25zLmhvc3R9L21hcHMvc3R5bGVzLyR7c3R5bGV9YDtcbiAgICBpZiAobWFwT3B0aW9ucy5sYW5ndWFnZSkge1xuICAgICAgICB1cmwgKz0gYD9sYW5ndWFnZT0ke21hcE9wdGlvbnMubGFuZ3VhZ2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG4vLyBjaGVjayBpZiBzdHlsZSBpcyBhIFJhZGFyIHN0eWxlIG9yIGEgY3VzdG9tIHN0eWxlXG5jb25zdCBpc1JhZGFyU3R5bGUgPSAoc3R5bGUpID0+IHtcbiAgICBpZiAoUkFEQVJfU1RZTEVTLmluY2x1ZGVzKHN0eWxlKSkgeyAvLyBSYWRhciBidWlsdC1pbiBzdHlsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEvXihodHRwOnxodHRwczopLy50ZXN0KHN0eWxlKSkgeyAvLyBSYWRhciBjdXN0b20gc3R5bGUgKG5vdCBhIFVSTClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vLyB1c2UgZm9ybWF0dGVkIHN0eWxlIFVSTCBpZiB1c2luZyBvbmUgb2YgUmFkYXIncyBvdXQtb2YtdGhlLWJveCBzdHlsZXMgb3IgaXMgYSBSYWRhciBjdXN0b20gc3R5bGVcbmNvbnN0IGdldFN0eWxlID0gKG9wdGlvbnMsIG1hcE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IG1hcE9wdGlvbnMuc3R5bGU7XG4gICAgaWYgKCFzdHlsZSB8fCAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyAmJiBpc1JhZGFyU3R5bGUoc3R5bGUpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3R5bGVVUkwob3B0aW9ucywgbWFwT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBtYXBPcHRpb25zLnN0eWxlOyAvLyBzdHlsZSBvYmplY3Qgb3IgVVJMXG59O1xuY2xhc3MgUmFkYXJNYXAgZXh0ZW5kcyBtYXBsaWJyZWdsLk1hcCB7XG4gICAgY29uc3RydWN0b3IocmFkYXJNYXBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgaWYgKCFjb25maWcucHVibGlzaGFibGVLZXkpIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCdwdWJsaXNoYWJsZUtleSBub3Qgc2V0LiBDYWxsIFJhZGFyLmluaXRpYWxpemUoKSB3aXRoIGtleSBiZWZvcmUgY3JlYXRpbmcgYSBuZXcgbWFwLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbmZpZ3VyZSBtYXAgb3B0aW9uc1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldFN0eWxlKGNvbmZpZywgcmFkYXJNYXBPcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWFwT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRSYWRhck1hcE9wdGlvbnMsIGRlZmF1bHRNYXBsaWJyZU9wdGlvbnMsIHJhZGFyTWFwT3B0aW9ucywgeyBzdHlsZSB9KTtcbiAgICAgICAgTG9nZ2VyLmRlYnVnKGBpbml0aWFsaXplIG1hcCB3aXRoIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkobWFwT3B0aW9ucyl9YCk7XG4gICAgICAgIG1hcE9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdCA9ICh1cmwsIHJlc291cmNlVHlwZSkgPT4ge1xuICAgICAgICAgICAgLy8gdGhpcyBoYW5kbGVzIHdoZW4gYSBzdHlsZSBpcyBzd2l0Y2hlZFxuICAgICAgICAgICAgaWYgKHJlc291cmNlVHlwZSA9PT0gJ1N0eWxlJyAmJiBpc1JhZGFyU3R5bGUodXJsKSkge1xuICAgICAgICAgICAgICAgIHVybCA9IGNyZWF0ZVN0eWxlVVJMKGNvbmZpZywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zKSwgeyBzdHlsZTogdXJsIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogY29uZmlnLnB1Ymxpc2hhYmxlS2V5LFxuICAgICAgICAgICAgICAgICdYLVJhZGFyLURldmljZS1UeXBlJzogJ1dlYicsXG4gICAgICAgICAgICAgICAgJ1gtUmFkYXItU0RLLVZlcnNpb24nOiBTREtfVkVSU0lPTixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGNvbmZpZy5nZXRSZXF1ZXN0SGVhZGVycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHVybCwgaGVhZGVycyB9O1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtYXBPcHRpb25zKTsgLy8gaW5pdGlhbGl6ZSBNYXBMaWJyZSBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyLnN0eWxlLndpZHRoICYmICFjb250YWluZXIuc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBMb2dnZXIud2FybignbWFwIGNvbnRhaW5lciBkb2VzIG5vdCBoYXZlIGEgc2V0IFwid2lkdGhcIiBvciBcImhlaWdodFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHJhZGFyIGxvZ29cbiAgICAgICAgY29uc3QgcmFkYXJMb2dvID0gbmV3IFJhZGFyTG9nb0NvbnRyb2woKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHJhZGFyTG9nbywgJ2JvdHRvbS1sZWZ0Jyk7XG4gICAgICAgIC8vIGFkZCBhdHRyaWJ1dGlvblxuICAgICAgICBjb25zdCBhdHRyaWJ1dGlvbiA9IG5ldyBtYXBsaWJyZWdsLkF0dHJpYnV0aW9uQ29udHJvbCh7IGNvbXBhY3Q6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2woYXR0cmlidXRpb24sICdib3R0b20tcmlnaHQnKTtcbiAgICAgICAgLy8gYWRkIHpvb20gY29udHJvbHNcbiAgICAgICAgY29uc3QgbmF2ID0gbmV3IG1hcGxpYnJlZ2wuTmF2aWdhdGlvbkNvbnRyb2woe1xuICAgICAgICAgICAgc2hvd0NvbXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1pvb206IG1hcE9wdGlvbnMuc2hvd1pvb21Db250cm9scyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuYXYsICdib3R0b20tcmlnaHQnKTtcbiAgICAgICAgLy8gaGFuZGxlIG1hcCByZXNpemUgYWN0aW9uc1xuICAgICAgICBjb25zdCBvblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYXBsaWJyZWdsLWN0cmwtYXR0cmliJyk7XG4gICAgICAgICAgICBpZiAoYXR0cmliKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldENvbnRhaW5lcigpLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8IDM4MCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICAgIHRoaXMub24oJ2xvYWQnLCBvblJlc2l6ZSk7XG4gICAgfVxuICAgIGFkZE1hcmtlcihtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5wdXNoKG1hcmtlcik7XG4gICAgfVxuICAgIHJlbW92ZU1hcmtlcihtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IHRoaXMuX21hcmtlcnMuZmlsdGVyKChtYXBNYXJrZXIpID0+IG1hcE1hcmtlciAhPT0gbWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnM7XG4gICAgfVxuICAgIGZpdFRvTWFya2VycyhmaXRCb3VuZHNPcHRpb25zID0ge30sIG92ZXJyaWRlTWFya2Vycykge1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gb3ZlcnJpZGVNYXJrZXJzIHx8IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3VuZHMgPSBuZXcgbWFwbGlicmVnbC5MbmdMYXRCb3VuZHMoKTtcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQobWFya2VyLmdldExuZ0xhdCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRGaXRNYXJrZXJzT3B0aW9ucywgZml0Qm91bmRzT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZml0Qm91bmRzKGJvdW5kcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNsZWFyTWFya2VycygpIHtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIG1hcmtlci5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZXM7XG4gICAgfVxuICAgIGZpdFRvRmVhdHVyZXMoZml0Qm91bmRzT3B0aW9ucyA9IHt9LCBvdmVycmlkZUZlYXR1cmVzKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gKG92ZXJyaWRlRmVhdHVyZXMgfHwgdGhpcy5fZmVhdHVyZXMpLm1hcCgobWFwRmVhdHVyZSkgPT4gbWFwRmVhdHVyZS5fZmVhdHVyZSk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGdldEFsbENvb3JkcyhmZWF0dXJlcyk7XG4gICAgICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gbmV3IG1hcGxpYnJlZ2wuTG5nTGF0Qm91bmRzKCk7XG4gICAgICAgICAgICBjb29yZHMuZm9yRWFjaCgoY29vcmQpID0+IHtcbiAgICAgICAgICAgICAgICBib3VuZHMuZXh0ZW5kKGNvb3JkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5maXRCb3VuZHMoYm91bmRzLCBmaXRCb3VuZHNPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGZlYXR1cmVzIGZyb20gdGhlIG1hcFxuICAgIGNsZWFyRmVhdHVyZXMoKSB7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGZlYXR1cmUucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRQb2x5Z29uKHBvbHlnb24sIHBvbHlnb25PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgUmFkYXJQb2x5Z29uRmVhdHVyZSh0aGlzLCBwb2x5Z29uLCBwb2x5Z29uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cbiAgICBhZGRMaW5lKGxpbmUsIGxpbmVPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgUmFkYXJMaW5lRmVhdHVyZSh0aGlzLCBsaW5lLCBsaW5lT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cbiAgICBhZGRQb2x5bGluZShwb2x5bGluZSwgcG9seWxpbmVPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBSYWRhckxpbmVGZWF0dXJlLmZyb21Qb2x5bGluZSh0aGlzLCBwb2x5bGluZSwgcG9seWxpbmVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxufVxuXG5jbGFzcyBSYWRhck1hcmtlck1vdXNlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG1hcmtlciwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG1hcmtlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG1hcmtlci5fcG9zO1xuICAgICAgICB0aGlzLmxuZ0xhdCA9IG1hcmtlci5nZXRMbmdMYXQoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG4vLyBjYWNoZSBVUkwgbG9hZGVkIG1hcmtlcnNcbmNvbnN0IElNQUdFX0NBQ0hFID0gbmV3IE1hcCgpO1xuY29uc3QgdXNlQ2FjaGVkSW1hZ2UgPSAodXJsLCB0aW1lb3V0TVMgPSA1MDAwKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFJTUFHRV9DQUNIRS5oYXModXJsKSkgeyAvLyBub3RoaW5nIGluIGNhY2hlXG4gICAgICAgIElNQUdFX0NBQ0hFLnNldCh1cmwsICdwZW5kaW5nJyk7IC8vIHJlcXVlc3QgaW4gZmxpZ2h0XG4gICAgICAgIHJldHVybiByZWplY3QoJ21pc3MnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gSU1BR0VfQ0FDSEUuZ2V0KHVybCk7XG4gICAgICAgIGlmIChjYWNoZWREYXRhID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGlmICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA+IHRpbWVvdXRNUykgeyAvLyBjYWNoZSBsb29rdXAgdG9vayB0b28gbG9uZ1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgndGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FjaGVkRGF0YSA9PT0gJ2ZhaWxlZCcpIHsgLy8gcmVxdWVzdCBmYWlsZWRcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVqZWN0KCdmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWNoZWREYXRhICE9PSB1bmRlZmluZWQpIHsgLy8gcmV0dXJuIGRhdGFcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWREYXRhKTtcbiAgICAgICAgfVxuICAgIH0sIDEwMCk7XG59KTtcbmNvbnN0IGNyZWF0ZUltYWdlRWxlbWVudCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGVsZW1lbnQuc3JjID0gb3B0aW9ucy51cmw7XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLndpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy53aWR0aCAmJiAhb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXhXaWR0aCA9ICc2NHB4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSAnNjRweCc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG5jb25zdCBkZWZhdWx0TWFya2VyT3B0aW9ucyA9IHtcbiAgICBjb2xvcjogJyMwMDAyNTcnLFxufTtcbmNsYXNzIFJhZGFyTWFya2VyIGV4dGVuZHMgbWFwbGlicmVnbC5NYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG1hcmtlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFwbGlicmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE1hcmtlck9wdGlvbnMpO1xuICAgICAgICAvLyBpbml0IE1hcExpYnJlIG1hcmtlciBjb25maWdzXG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLmNvbG9yKSB7XG4gICAgICAgICAgICBtYXBsaWJyZU9wdGlvbnMuY29sb3IgPSBtYXJrZXJPcHRpb25zLmNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1hcGxpYnJlT3B0aW9ucy5lbGVtZW50ID0gbWFya2VyT3B0aW9ucy5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLnNjYWxlKSB7XG4gICAgICAgICAgICBtYXBsaWJyZU9wdGlvbnMuc2NhbGUgPSBtYXJrZXJPcHRpb25zLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG1hcGxpYnJlT3B0aW9ucyk7XG4gICAgICAgIC8vIGhhbmRsZSBtYXJrZXIgaW1hZ2VzIChSYWRhciBtYXJrZXIsIG9yIGN1c3RvbSBVUkwpXG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLm1hcmtlciB8fCBtYXJrZXJPcHRpb25zLnVybCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb25TdWNjZXNzID0gKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQucmVwbGFjZUNoaWxkcmVuKGNyZWF0ZUltYWdlRWxlbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtYXJrZXJPcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1hcmtlck9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBDb3VsZCBub3QgbG9hZCBtYXJrZXI6ICR7ZXJyLm1lc3NhZ2V9IC0gZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQgbWFya2VyYCk7XG4gICAgICAgICAgICAgICAgSU1BR0VfQ0FDSEUuc2V0KG1hcmtlck9wdGlvbnMudXJsLCAnZmFpbGVkJyk7IC8vIG1hcmsgYXMgZmFpbGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oLi4uQXJyYXkuZnJvbShvcmlnaW5hbEVsZW1lbnQuY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGN1c3RvbSBVUkwgaW1hZ2VcbiAgICAgICAgICAgIGlmIChtYXJrZXJPcHRpb25zLnVybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRJbWFnZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2gobWFya2VyT3B0aW9ucy51cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5ibG9iKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU1BR0VfQ0FDSEUuc2V0KG1hcmtlck9wdGlvbnMudXJsLCB1cmwpOyAvLyBjYWNoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzcyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gob25FcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIHVzZSBjYWNoZWQgZGF0YSwgb3RoZXJ3aXNlIGZldGNoIG1hcmtlciBpbWFnZSBkYXRhIGZyb20gVVJMXG4gICAgICAgICAgICAgICAgdXNlQ2FjaGVkSW1hZ2UobWFya2VyT3B0aW9ucy51cmwpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbiAhPT0gJ21pc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZGVidWcoYFJhZGFyTWFya2VyOiBjYWNoZSBsb29rdXAgZm9yICR7bWFya2VyT3B0aW9ucy51cmx9OiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2FkSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJhZGFyIGhvc3RlZCBpbWFnZVxuICAgICAgICAgICAgaWYgKG1hcmtlck9wdGlvbnMubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZE1hcmtlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnbWFwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgbWFya2Vycy8ke21hcmtlck9wdGlvbnMubWFya2VyfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIElNQUdFX0NBQ0hFLnNldChtYXJrZXJPcHRpb25zLm1hcmtlciwgdXJsKTsgLy8gY2FjaGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gob25FcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB1c2VDYWNoZWRJbWFnZShtYXJrZXJPcHRpb25zLm1hcmtlcilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ob25TdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhc29uICE9PSAnbWlzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5kZWJ1ZyhgUmFkYXJNYXJrZXI6IGNhY2hlIGxvb2t1cCBmb3IgJHttYXJrZXJPcHRpb25zLm1hcmtlcn0gJHtyZWFzb259YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZE1hcmtlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBkZXByZWNhdGVkIHBvcHVwIG9wdGlvbnNcbiAgICAgICAgaWYgKG1hcmtlck9wdGlvbnMudGV4dCkge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ21hcmtlciBvcHRpb24gXCJ0ZXh0XCIgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBVc2UgXCJwb3B1cC50ZXh0XCIuJyk7XG4gICAgICAgICAgICBtYXJrZXJPcHRpb25zLnBvcHVwID0gbWFya2VyT3B0aW9ucy5wb3B1cCB8fCB7fTtcbiAgICAgICAgICAgIG1hcmtlck9wdGlvbnMucG9wdXAudGV4dCA9IG1hcmtlck9wdGlvbnMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyT3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICBMb2dnZXIud2FybignbWFya2VyIG9wdGlvbiBcImh0bWxcIiBpcyBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFVzZSBcInBvcHVwLmh0bWxcIi4nKTtcbiAgICAgICAgICAgIG1hcmtlck9wdGlvbnMucG9wdXAgPSBtYXJrZXJPcHRpb25zLnBvcHVwIHx8IHt9O1xuICAgICAgICAgICAgbWFya2VyT3B0aW9ucy5wb3B1cC5odG1sID0gbWFya2VyT3B0aW9ucy5odG1sO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBwb3B1cCB0ZXh0IG9yIEhUTUxcbiAgICAgICAgaWYgKG1hcmtlck9wdGlvbnMucG9wdXApIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IG1hcGxpYnJlZ2wuUG9wdXAobWFya2VyT3B0aW9ucy5wb3B1cCk7XG4gICAgICAgICAgICBpZiAobWFya2VyT3B0aW9ucy5wb3B1cC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgcG9wdXAuc2V0VGV4dChtYXJrZXJPcHRpb25zLnBvcHVwLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcmtlck9wdGlvbnMucG9wdXAuaHRtbCkge1xuICAgICAgICAgICAgICAgIHBvcHVwLnNldEhUTUwobWFya2VyT3B0aW9ucy5wb3B1cC5odG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXJPcHRpb25zLnBvcHVwLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwb3B1cC5zZXRET01Db250ZW50KG1hcmtlck9wdGlvbnMucG9wdXAuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFBvcHVwKHBvcHVwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXNzLXRocm91Z2ggY2xpY2sgZXZlbnQgZnJvbSBlbGVtZW50IHRvIG1hcmtlclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBwcmV2ZW50IGNsaWNrcyBmcm9tIHByb3BhZ2F0aW5nIHRvIG1hcFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIHN0b3BwaW5nIHRoZSBwcm9wYWdhdGlvbiB0byBtYXAsXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtYW51YWxseSB0b2dnbGUgdGhlIHBvcHVwIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFya2VyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UG9wdXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBhbnkgb3RoZXIgb3BlbiBwb3B1cHNcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRNYXJrZXJzKCkgfHwgW10pLmZvckVhY2goKG90aGVyTWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gb3RoZXJNYXJrZXIuZ2V0UG9wdXAoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJNYXJrZXIudG9nZ2xlUG9wdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlUG9wdXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIG5ldyBSYWRhck1hcmtlck1vdXNlRXZlbnQoJ2NsaWNrJywgdGhpcywgZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVG8obWFwKSB7XG4gICAgICAgIG1hcC5hZGRNYXJrZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRUbyhtYXApO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVNYXJrZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgUmFkYXJQb3B1cCBleHRlbmRzIG1hcGxpYnJlZ2wuUG9wdXAge1xuICAgIGNvbnN0cnVjdG9yKHBvcHVwT3B0aW9ucykge1xuICAgICAgICBzdXBlcihwb3B1cE9wdGlvbnMpO1xuICAgICAgICBpZiAocG9wdXBPcHRpb25zLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dChwb3B1cE9wdGlvbnMudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcHVwT3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhUTUwocG9wdXBPcHRpb25zLmh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3B1cE9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRET01Db250ZW50KHBvcHVwT3B0aW9ucy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTWFwVUkge1xuICAgIHN0YXRpYyBnZXRNYXBMaWJyZSgpIHtcbiAgICAgICAgcmV0dXJuIG1hcGxpYnJlZ2w7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVNYXAobWFwT3B0aW9ucykge1xuICAgICAgICBjb25zdCByYWRhck1hcCA9IG5ldyBSYWRhck1hcChtYXBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJhZGFyTWFwO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlTWFya2VyKG1hcmtlck9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByYWRhck1hcmtlciA9IG5ldyBSYWRhck1hcmtlcihtYXJrZXJPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJhZGFyTWFya2VyO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUG9wdXAocG9wdXBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IFJhZGFyUG9wdXAocG9wdXBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBvcHVwO1xuICAgIH1cbn1cblxuY29uc3QgQ0xBU1NOQU1FUyA9IHtcbiAgICBXUkFQUEVSOiAncmFkYXItYXV0b2NvbXBsZXRlLXdyYXBwZXInLFxuICAgIElOUFVUOiAncmFkYXItYXV0b2NvbXBsZXRlLWlucHV0JyxcbiAgICBTRUFSQ0hfSUNPTjogJ3JhZGFyLWF1dG9jb21wbGV0ZS1zZWFyY2gtaWNvbicsXG4gICAgUkVTVUxUU19MSVNUOiAncmFkYXItYXV0b2NvbXBsZXRlLXJlc3VsdHMtbGlzdCcsXG4gICAgUkVTVUxUU19JVEVNOiAncmFkYXItYXV0b2NvbXBsZXRlLXJlc3VsdHMtaXRlbScsXG4gICAgUkVTVUxUU19NQVJLRVI6ICdyYWRhci1hdXRvY29tcGxldGUtcmVzdWx0cy1tYXJrZXInLFxuICAgIFNFTEVDVEVEX0lURU06ICdyYWRhci1hdXRvY29tcGxldGUtcmVzdWx0cy1pdGVtLXNlbGVjdGVkJyxcbiAgICBQT1dFUkVEX0JZX1JBREFSOiAncmFkYXItcG93ZXJlZCcsXG4gICAgTk9fUkVTVUxUUzogJ3JhZGFyLW5vLXJlc3VsdHMnLFxufTtcbmNvbnN0IGRlZmF1bHRBdXRvY29tcGxldGVPcHRpb25zID0ge1xuICAgIGNvbnRhaW5lcjogJ2F1dG9jb21wbGV0ZScsXG4gICAgZGVib3VuY2VNUzogMjAwLFxuICAgIG1pbkNoYXJhY3RlcnM6IDMsXG4gICAgbGltaXQ6IDgsXG4gICAgcGxhY2Vob2xkZXI6ICdTZWFyY2ggYWRkcmVzcycsXG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc2hvd01hcmtlcnM6IHRydWUsXG4gICAgaGlkZVJlc3VsdHNPbkJsdXI6IHRydWUsXG59O1xuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHB4IG9yIENTUyBzdHJpbmdcbmNvbnN0IGZvcm1hdENTU1ZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IERFRkFVTFRfV0lEVEggPSA0MDA7XG5jb25zdCBzZXRXaWR0aCA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIGlmIHJlc3BvbnNpdmUgYW5kIHdpZHRoIGlzIHByb3ZpZGVkLCB0cmVhdCBpdCBhcyBtYXhXaWR0aFxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgaW5wdXQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICAgICAgICBpbnB1dC5zdHlsZS5tYXhXaWR0aCA9IGZvcm1hdENTU1ZhbHVlKG9wdGlvbnMud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgbm90IHJlc3BvbnNpdmUsIHNldCBmaXhlZCB3aWR0aCBhbmQgdW5zZXQgbWF4V2lkdGhcbiAgICBpbnB1dC5zdHlsZS53aWR0aCA9IGZvcm1hdENTU1ZhbHVlKG9wdGlvbnMud2lkdGggfHwgREVGQVVMVF9XSURUSCk7XG4gICAgaW5wdXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21heC13aWR0aCcpO1xufTtcbmNvbnN0IHNldEhlaWdodCA9IChyZXN1bHRzTGlzdCwgb3B0aW9ucykgPT4ge1xuICAgIGlmIChvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgICByZXN1bHRzTGlzdC5zdHlsZS5tYXhIZWlnaHQgPSBmb3JtYXRDU1NWYWx1ZShvcHRpb25zLm1heEhlaWdodCk7XG4gICAgICAgIHJlc3VsdHNMaXN0LnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJzsgLyogYWxsb3cgb3ZlcmZsb3cgd2hlbiBtYXhIZWlnaHQgaXMgYXBwbGllZCAqL1xuICAgIH1cbn07XG5jb25zdCBnZXRNYXJrZXJJY29uID0gKGNvbG9yID0gXCIjQUNCREM4XCIpID0+IHtcbiAgICBjb25zdCBmaWxsID0gY29sb3IucmVwbGFjZSgnIycsICclMjMnKTtcbiAgICBjb25zdCBzdmcgPSBgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgPHBhdGggZD1cIk0xMi41NzA0IDYuNTcwMzZDMTIuNTcwNCA0LjExNjMyIDEwLjYzNDIgMi4xMTI1NyA4LjIxMDE2IDJDOC4xNDI2MiAyIDguMDY3NTcgMiA4LjAwMDAzIDJDNy45MzI0OSAyIDcuODU3NDQgMiA3Ljc4OTkgMkM1LjM1ODM4IDIuMTEyNTcgMy40Mjk2NyA0LjExNjMyIDMuNDI5NjcgNi41NzAzNkMzLjQyOTY3IDYuNjAwMzcgMy40Mjk2NyA2LjYzNzkgMy40Mjk2NyA2LjY2NzkyQzMuNDI5NjcgNi42OTc5NCAzLjQyOTY3IDYuNzM1NDYgMy40Mjk2NyA2Ljc2NTQ4QzMuNDI5NjcgOS40NjcxNyA3LjA5MTk2IDEzLjM2MjEgNy40NjcyIDEzLjc1OThDNy42MTcyOSAxMy45MTc0IDcuODQ5OTQgMTQgOC4wMDAwMyAxNEM4LjE1MDEyIDE0IDguMzgyNzcgMTMuOTE3NCA4LjUzMjg2IDEzLjc1OThDOC45MTU2IDEzLjM2MjEgMTIuNTcwNCA5LjQ2NzE3IDEyLjU3MDQgNi43NjU0OEMxMi41NzA0IDYuNzI3OTUgMTIuNTcwNCA2LjY5Nzk0IDEyLjU3MDQgNi42Njc5MkMxMi41NzA0IDYuNjM3OSAxMi41NzA0IDYuNjAwMzcgMTIuNTcwNCA2LjU3MDM2Wk03Ljk5MjUyIDguMjg4OTNDNy4wNDY5MyA4LjI4ODkzIDYuMjczOTUgNy41MjM0NSA2LjI3Mzk1IDYuNTcwMzZDNi4yNzM5NSA1LjYxNzI2IDcuMDM5NDMgNC44NTE3OCA3Ljk5MjUyIDQuODUxNzhDOC45NDU2MiA0Ljg1MTc4IDkuNzExMSA1LjYxNzI2IDkuNzExMSA2LjU3MDM2QzkuNzExMSA3LjUyMzQ1IDguOTQ1NjIgOC4yODg5MyA3Ljk5MjUyIDguMjg4OTNaXCIgZmlsbD1cIiR7ZmlsbH1cIi8+XG4gIDwvc3ZnPmAudHJpbSgpO1xuICAgIHJldHVybiBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtzdmd9YDtcbn07XG5jbGFzcyBBdXRvY29tcGxldGVVSSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IEF1dG9jb21wbGV0ZVVJIGluc3RhbmNlXG4gICAgc3RhdGljIGNyZWF0ZUF1dG9jb21wbGV0ZShhdXRvY29tcGxldGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0b2NvbXBsZXRlVUkoYXV0b2NvbXBsZXRlT3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRBdXRvY29tcGxldGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gc2V0dXAgc3RhdGVcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRGZXRjaFJlc3VsdHMgPSB0aGlzLmRlYm91bmNlKHRoaXMuZmV0Y2hSZXN1bHRzLCB0aGlzLmNvbmZpZy5kZWJvdW5jZU1TKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xuICAgICAgICAvLyBzZXQgdGhyZXNob2xkIGFsaWFzXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcubWluQ2hhcmFjdGVycyA9IHRoaXMuY29uZmlnLnRocmVzaG9sZDtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCdBdXRvY29tcGxldGVVSSBvcHRpb24gXCJ0aHJlc2hvbGRcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCJtaW5DaGFyYWN0ZXJzXCIgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5uZWFyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubmVhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lYXIgPSBvcHRpb25zLm5lYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lYXIgPSBgJHtvcHRpb25zLm5lYXIubGF0aXR1ZGV9LCR7b3B0aW9ucy5uZWFyLmxvbmdpdHVkZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjb250YWluZXIgZWxlbWVudFxuICAgICAgICBsZXQgY29udGFpbmVyRUw7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcuY29udGFpbmVyID09PSAnc3RyaW5nJykgeyAvLyBsb29rdXAgY29udGFpbmVyIGVsZW1lbnQgYnkgSURcbiAgICAgICAgICAgIGNvbnRhaW5lckVMID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gdXNlIHByb3ZpZGVkIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnRhaW5lckVMID0gdGhpcy5jb25maWcuY29udGFpbmVyOyAvLyBIVE1MRWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyRUwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWRhckF1dG9jb21wbGV0ZUNvbnRhaW5lck5vdEZvdW5kKGBDb3VsZCBub3QgZmluZCBjb250YWluZXIgZWxlbWVudDogJHt0aGlzLmNvbmZpZy5jb250YWluZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJFTDtcbiAgICAgICAgLy8gY3JlYXRlIHdyYXBwZXIgZm9yIGlucHV0IGFuZCByZXN1bHQgbGlzdFxuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQoQ0xBU1NOQU1FUy5XUkFQUEVSKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSB0aGlzLmNvbmZpZy5yZXNwb25zaXZlID8gJ2Jsb2NrJyA6ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBzZXRXaWR0aCh0aGlzLndyYXBwZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgLy8gcmVzdWx0IGxpc3QgZWxlbWVudFxuICAgICAgICB0aGlzLnJlc3VsdHNMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuUkVTVUxUU19MSVNUKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5zZXRBdHRyaWJ1dGUoJ2lkJywgQ0xBU1NOQU1FUy5SRVNVTFRTX0xJU1QpO1xuICAgICAgICB0aGlzLnJlc3VsdHNMaXN0LnNldEF0dHJpYnV0ZSgncm9sZScsICdsaXN0Ym94Jyk7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3Quc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3Quc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1NlYXJjaCByZXN1bHRzJyk7XG4gICAgICAgIHNldEhlaWdodCh0aGlzLnJlc3VsdHNMaXN0LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmIChjb250YWluZXJFTC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgLy8gaWYgYW4gPGlucHV0PiBlbGVtZW50IGlzIHByb3ZpZGVkLCB1c2UgdGhhdCBhcyB0aGUgaW5wdXRGaWVsZCxcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmQgdGhlIHJlc3VsdExpc3QgdG8gaXQncyBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQgPSBjb250YWluZXJFTDtcbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBkb21cbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnJlc3VsdHNMaXN0KTtcbiAgICAgICAgICAgIGNvbnRhaW5lckVMLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBub3QgYW4gaW5wdXQsIGNyZWF0ZSBuZXcgaW5wdXQgYW5kIGFwcGVuZCB0byBjb250YWluZXJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLklOUFVUKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5wbGFjZWhvbGRlciA9IHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZGlzYWJsZWQgPSB0aGlzLmNvbmZpZy5kaXNhYmxlZDtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpY29uXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzZWFyY2hJY29uLmNsYXNzTGlzdC5hZGQoQ0xBU1NOQU1FUy5TRUFSQ0hfSUNPTik7XG4gICAgICAgICAgICAvLyBhcHBlbmQgdG8gRE9NXG4gICAgICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnJlc3VsdHNMaXN0KTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChzZWFyY2hJY29uKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZSBicm93c2VyIGF1dG9maWxsXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcbiAgICAgICAgLy8gc2V0IGFyaWEgcm9sZXNcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgncm9sZScsICdjb21ib2JveCcpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgQ0xBU1NOQU1FUy5SRVNVTFRTX0xJU1QpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCAnbGlzdGJveCcpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWF1dG9jb21wbGV0ZScsICdsaXN0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsICcnKTtcbiAgICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuaGFuZGxlSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlib2FyZE5hdmlnYXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5oaWRlUmVzdWx0c09uQmx1cikge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLmNsb3NlLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5kZWJ1ZyhgQXV0b2NvbXBsZXRlVUkgaW5pYWlsaXplZCB3aXRoIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpfWApO1xuICAgIH1cbiAgICBoYW5kbGVJbnB1dCgpIHtcbiAgICAgICAgLy8gRmV0Y2ggYXV0b2NvbXBsZXRlIHJlc3VsdHMgYW5kIGRpc3BsYXkgdGhlbVxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA8IHRoaXMuY29uZmlnLm1pbkNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYm91bmNlZEZldGNoUmVzdWx0cyhxdWVyeSlcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvblJlc3VsdHMgPSB0aGlzLmNvbmZpZy5vblJlc3VsdHM7XG4gICAgICAgICAgICBpZiAob25SZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgb25SZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5UmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKGBBdXRvY29tcGxldGUgdWkgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSB0aGlzLmNvbmZpZy5vbkVycm9yO1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICBsZXQgcmVzb2x2ZUZuO1xuICAgICAgICBsZXQgcmVqZWN0Rm47XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVGbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVGbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVqZWN0Rm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RGbihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUZuID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWplY3RGbiA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmZXRjaFJlc3VsdHMocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGltaXQsIGxheWVycywgY291bnRyeUNvZGUsIGV4cGFuZFVuaXRzLCBtYWlsYWJsZSwgb25SZXF1ZXN0IH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICBsYXllcnMsXG4gICAgICAgICAgICAgICAgY291bnRyeUNvZGUsXG4gICAgICAgICAgICAgICAgZXhwYW5kVW5pdHMsXG4gICAgICAgICAgICAgICAgbWFpbGFibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubmVhcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5uZWFyID0gdGhpcy5uZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIG9uUmVxdWVzdChwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzZXMgfSA9IHlpZWxkIFNlYXJjaEFQSS5hdXRvY29tcGxldGUocGFyYW1zLCAnYXV0b2NvbXBsZXRlLXVpJyk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcGxheVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAvLyBDbGVhciB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICAgICAgICB0aGlzLmNsZWFyUmVzdWx0c0xpc3QoKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgbGV0IG1hcmtlcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNob3dNYXJrZXJzKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIG1hcmtlci5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuUkVTVUxUU19NQVJLRVIpO1xuICAgICAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZSgnc3JjJywgZ2V0TWFya2VySWNvbih0aGlzLmNvbmZpZy5tYXJrZXJDb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYXBwZW5kIGxpc3QgaXRlbXMgZm9yIGVhY2ggcmVzdWx0XG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlJFU1VMVFNfSVRFTSk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2lkJywgYCR7Q0xBU1NOQU1FUy5SRVNVTFRTX0lURU19fS0ke2luZGV4fWApO1xuICAgICAgICAgICAgLy8gY29uc3RydWN0IHJlc3VsdCB3aXRoIGJvbGRlZCBsYWJlbFxuICAgICAgICAgICAgbGV0IGxpc3RDb250ZW50O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5mb3JtYXR0ZWRBZGRyZXNzLmluY2x1ZGVzKHJlc3VsdC5hZGRyZXNzTGFiZWwpICYmIHJlc3VsdC5sYXllciAhPT0gJ3Bvc3RhbENvZGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWRkcmVzc0xhYmVsIGlzIGNvbnRhaW5lZCBpbiB0aGUgZm9ybWF0dGVkIGFkZHJlc3MsIGJvbGQgdGhlIGFkZHJlc3MgbGFiZWxcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYCgke3Jlc3VsdC5hZGRyZXNzTGFiZWx9KSw/YCk7XG4gICAgICAgICAgICAgICAgbGlzdENvbnRlbnQgPSByZXN1bHQuZm9ybWF0dGVkQWRkcmVzcy5yZXBsYWNlKHJlZ2V4LCAnPGI+JDE8L2I+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYXBwZW5kIHRoZSBhZGRyZXNzIG9yIHBsYWNlIGxhYmVsIHRvIGZvcm1hdHRlZCBhZGRyZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSByZXN1bHQucGxhY2VMYWJlbCB8fCByZXN1bHQuYWRkcmVzc0xhYmVsO1xuICAgICAgICAgICAgICAgIGxpc3RDb250ZW50ID0gYDxiPiR7bGFiZWx9PC9iPiAke3Jlc3VsdC5mb3JtYXR0ZWRBZGRyZXNzfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaS5pbm5lckhUTUwgPSBsaXN0Q29udGVudDtcbiAgICAgICAgICAgIC8vIHByZXBlbmQgbWFya2VyIGlmIGVuYWJsZWRcbiAgICAgICAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBsaS5wcmVwZW5kKG1hcmtlci5jbG9uZU5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgY2xpY2sgaGFuZGxlciB0byBlYWNoIHJlc3VsdCwgdXNlIG1vdXNlZG93biB0byBmaXJlIGJlZm9yZSBibHVyIGV2ZW50XG4gICAgICAgICAgICBsaS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNMaXN0LmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgbGluay5ocmVmID0gJ2h0dHBzOi8vcmFkYXIuY29tP3JlZj1wb3dlcmVkX2J5X3JhZGFyJztcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICB0aGlzLnBvd2VyZWRCeUxpbmsgPSBsaW5rO1xuICAgICAgICAgICAgY29uc3QgcG93ZXJlZEJ5VGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHBvd2VyZWRCeVRleHQudGV4dENvbnRlbnQgPSAnUG93ZXJlZCBieSc7XG4gICAgICAgICAgICBsaW5rLmFwcGVuZENoaWxkKHBvd2VyZWRCeVRleHQpO1xuICAgICAgICAgICAgY29uc3QgcmFkYXJMb2dvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcmFkYXJMb2dvLmlkID0gJ3JhZGFyLXBvd2VyZWQtbG9nbyc7XG4gICAgICAgICAgICByYWRhckxvZ28udGV4dENvbnRlbnQgPSAnUmFkYXInO1xuICAgICAgICAgICAgbGluay5hcHBlbmRDaGlsZChyYWRhckxvZ28pO1xuICAgICAgICAgICAgY29uc3QgcG93ZXJlZEJ5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwb3dlcmVkQnlDb250YWluZXIuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlBPV0VSRURfQllfUkFEQVIpO1xuICAgICAgICAgICAgcG93ZXJlZEJ5Q29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5hcHBlbmRDaGlsZChwb3dlcmVkQnlDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9SZXN1bHRzVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9SZXN1bHRzVGV4dC5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuTk9fUkVTVUxUUyk7XG4gICAgICAgICAgICBub1Jlc3VsdHNUZXh0LnRleHRDb250ZW50ID0gJ05vIHJlc3VsdHMnO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5hcHBlbmRDaGlsZChub1Jlc3VsdHNUZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5yZW1vdmVBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgfVxuICAgIGNsb3NlKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGlzIGNvZGUgYXN5bmMgdG8gYWxsb3cgbGluayBjbGljayB0byBwcm9wYWdhdGUgYmVmb3JlIGJsdXJcbiAgICAgICAgLy8gKGFkZCAxMDBtcyBkZWxheSBpZiBjbG9zZWQgZnJvbSBsaW5rIGNsaWNrKVxuICAgICAgICBjb25zdCBsaW5rQ2xpY2sgPSBlICYmIChlLnJlbGF0ZWRUYXJnZXQgPT09IHRoaXMucG93ZXJlZEJ5TGluayk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJycpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICcnKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJSZXN1bHRzTGlzdCgpO1xuICAgICAgICB9LCBsaW5rQ2xpY2sgPyAxMDAgOiAwKTtcbiAgICB9XG4gICAgZ29UbyhpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA+PSB0aGlzLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0SXRlbXMgPSB0aGlzLnJlc3VsdHNMaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGNsYXNzIG5hbWVzIG9uIHByZXZpb3VzbHkgaGlnaGxpZ2h0ZWQgaXRlbVxuICAgICAgICAgICAgcmVzdWx0SXRlbXNbdGhpcy5oaWdobGlnaHRlZEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTTkFNRVMuU0VMRUNURURfSVRFTSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNsYXNzIG5hbWUgdG8gbmV3bHkgaGlnaGxpZ2h0ZWQgaXRlbVxuICAgICAgICByZXN1bHRJdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlNFTEVDVEVEX0lURU0pO1xuICAgICAgICAvLyBzZXQgYXJpYSBhY3RpdmUgZGVzY2VuZGFudFxuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBgJHtDTEFTU05BTUVTLlJFU1VMVFNfSVRFTX0tJHtpbmRleH1gKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGhhbmRsZUtleWJvYXJkTmF2aWdhdGlvbihldmVudCkge1xuICAgICAgICBsZXQga2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAvLyBhbGxvdyBldmVudCB0byBwcm9wYWdhdGUgaWYgcmVzdWx0IGxpc3QgaXMgbm90IG9wZW5cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHNoaWZ0K3RhYiBhcyB1cCBrZXlcbiAgICAgICAgaWYgKGtleSA9PT0gJ1RhYicgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGtleSA9ICdBcnJvd1VwJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gTmV4dCBpdGVtXG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ29Ubyh0aGlzLmhpZ2hsaWdodGVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFByZXYgaXRlbVxuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdvVG8odGhpcy5oaWdobGlnaHRlZEluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBTZWxlY3RcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmhpZ2hsaWdodGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ2xvc2VcbiAgICAgICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdChpbmRleCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdHNbaW5kZXhdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oYE5vIGF1dG9jb21wbGV0ZSByZXN1bHQgZm91bmQgYXQgaW5kZXg6ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0VmFsdWU7XG4gICAgICAgIGlmIChyZXN1bHQuZm9ybWF0dGVkQWRkcmVzcy5pbmNsdWRlcyhyZXN1bHQuYWRkcmVzc0xhYmVsKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHJlc3VsdC5mb3JtYXR0ZWRBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSByZXN1bHQucGxhY2VMYWJlbCB8fCByZXN1bHQuYWRkcmVzc0xhYmVsO1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2xhYmVsfSwgJHtyZXN1bHQuZm9ybWF0dGVkQWRkcmVzc31gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgIGNvbnN0IG9uU2VsZWN0aW9uID0gdGhpcy5jb25maWcub25TZWxlY3Rpb247XG4gICAgICAgIGlmIChvblNlbGVjdGlvbikge1xuICAgICAgICAgICAgb25TZWxlY3Rpb24ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciByZXN1bHRzIGxpc3RcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBjbGVhclJlc3VsdHNMaXN0KCkge1xuICAgICAgICB0aGlzLnJlc3VsdHNMaXN0LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gRE9NXG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBMb2dnZXIuZGVidWcoJ0F1dG9jb21wbGV0ZVVJIHJlbW92ZWQuJyk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZSgpO1xuICAgIH1cbiAgICBzZXROZWFyKG5lYXIpIHtcbiAgICAgICAgaWYgKG5lYXIgPT09IHVuZGVmaW5lZCB8fCBuZWFyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5lYXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5lYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZWFyID0gYCR7bmVhci5sYXRpdHVkZX0sJHtuZWFyLmxvbmdpdHVkZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UmVzcG9uc2l2ZShyZXNwb25zaXZlKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlc3BvbnNpdmUgPSByZXNwb25zaXZlO1xuICAgICAgICBzZXRXaWR0aCh0aGlzLndyYXBwZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHNldFdpZHRoKHRoaXMud3JhcHBlciwgdGhpcy5jb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TWF4SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHNldEhlaWdodCh0aGlzLnJlc3VsdHNMaXN0LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRNaW5DaGFyYWN0ZXJzKG1pbkNoYXJhY3RlcnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWluQ2hhcmFjdGVycyA9IG1pbkNoYXJhY3RlcnM7XG4gICAgICAgIHRoaXMuY29uZmlnLnRocmVzaG9sZCA9IG1pbkNoYXJhY3RlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRMaW1pdChsaW1pdCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5saW1pdCA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0U2hvd01hcmtlcnMoc2hvd01hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2hvd01hcmtlcnMgPSBzaG93TWFya2VycztcbiAgICAgICAgaWYgKHNob3dNYXJrZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIG1hcmtlci5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuUkVTVUxUU19NQVJLRVIpO1xuICAgICAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZSgnc3JjJywgZ2V0TWFya2VySWNvbih0aGlzLmNvbmZpZy5tYXJrZXJDb2xvcikpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0SXRlbXMgPSB0aGlzLnJlc3VsdHNMaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrZXIgPSByZXN1bHRJdGVtc1tpXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKENMQVNTTkFNRVMuUkVTVUxUU19NQVJLRVIpWzBdO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtc1tpXS5wcmVwZW5kKG1hcmtlci5jbG9uZU5vZGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0SXRlbXMgPSB0aGlzLnJlc3VsdHNMaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHJlc3VsdEl0ZW1zW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoQ0xBU1NOQU1FUy5SRVNVTFRTX01BUktFUilbMF07XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRNYXJrZXJDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXJrZXJDb2xvciA9IGNvbG9yO1xuICAgICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLnJlc3VsdHNMaXN0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoQ0xBU1NOQU1FUy5SRVNVTFRTX01BUktFUik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXJrZXJbaV0uc2V0QXR0cmlidXRlKCdzcmMnLCBnZXRNYXJrZXJJY29uKGNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEhpZGVSZXN1bHRzT25CbHVyKGhpZGVSZXN1bHRzT25CbHVyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmhpZGVSZXN1bHRzT25CbHVyID0gaGlkZVJlc3VsdHNPbkJsdXI7XG4gICAgICAgIGlmIChoaWRlUmVzdWx0c09uQmx1cikge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLmNsb3NlLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLmNsb3NlLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgUmFkYXIgZXh0ZW5kcyBSYWRhciQxIHtcbiAgICAvLyBcInVpXCIgbmFtZXNwYWNlIGZvciBNYXBzIGFuZCBBdXRvY29tcGxldGVcbiAgICBzdGF0aWMgZ2V0IHVpKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFwbGlicmVnbDogTWFwVUkuZ2V0TWFwTGlicmUoKSxcbiAgICAgICAgICAgIG1hcDogTWFwVUkuY3JlYXRlTWFwLFxuICAgICAgICAgICAgbWFya2VyOiBNYXBVSS5jcmVhdGVNYXJrZXIsXG4gICAgICAgICAgICBwb3B1cDogTWFwVUkuY3JlYXRlUG9wdXAsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IEF1dG9jb21wbGV0ZVVJLmNyZWF0ZUF1dG9jb21wbGV0ZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFJhZGFyIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGFyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/radar-sdk-js/dist/radar.js\n");

/***/ })

};
;